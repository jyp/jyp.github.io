<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Programming Paradigms: Lecture Notes</title>
<!-- 2016-03-03 tor 07:42 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Jean-Philippe Bernardy" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="pp.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/javascript" src="http://orgmode.org/mathjax/MathJax.js"></script>
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
    MathJax.Hub.Config({
        // Only one of the two following lines, depending on user settings
        // First allows browser-native MathML display, second forces HTML/CSS
        //  config: ["MMLorHTML.js"], jax: ["input/TeX"],
            jax: ["input/TeX", "output/HTML-CSS"],
        extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js",
                     "TeX/noUndefined.js"],
        tex2jax: {
            inlineMath: [ ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"], ["\\begin{displaymath}","\\end{displaymath}"] ],
            skipTags: ["script","noscript","style","textarea","pre","code"],
            ignoreClass: "tex2jax_ignore",
            processEscapes: false,
            processEnvironments: true,
            preview: "TeX"
        },
        showProcessingMessages: true,
        displayAlign: "center",
        displayIndent: "2em",

        "HTML-CSS": {
             scale: 100,
             availableFonts: ["STIX","TeX"],
             preferredFont: "TeX",
             webFont: "TeX",
             imageFont: "TeX",
             showMathMenu: true,
        },
        MMLorHTML: {
             prefer: {
                 MSIE:    "MML",
                 Firefox: "MML",
                 Opera:   "HTML",
                 other:   "HTML"
             }
        }
    });
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Programming Paradigms: Lecture Notes</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. ✪ What is a "programming paradigm"?</a>
<ul>
<li><a href="#sec-1-1">1.1. Definition</a></li>
<li><a href="#sec-1-2">1.2. Paradigms as "ways of organizing thought"</a></li>
<li><a href="#sec-1-3">1.3. Paradigms and Languages</a></li>
<li><a href="#sec-1-4">1.4. Fluidity between paradigms</a></li>
<li><a href="#sec-1-5">1.5. ✪ A remark on paradigm shift</a></li>
</ul>
</li>
<li><a href="#sec-2">2. Prelude: Abstraction and Types</a></li>
<li><a href="#sec-3">3. Imperative programming</a>
<ul>
<li><a href="#sec-3-1">3.1. Model: von Neumann computer</a></li>
<li><a href="#sec-3-2">3.2. Example: Sorting</a></li>
<li><a href="#sec-3-3">3.3. Transformation: Loops ⟶ Gotos</a></li>
<li><a href="#sec-3-4">3.4. Transformation: If then else ⟶ Gotos</a></li>
<li><a href="#sec-3-5">3.5. Reverse transformation: (Gotos ⟶ Loops)</a></li>
<li><a href="#sec-3-6">3.6. Transformation: inlining procedure calls</a></li>
<li><a href="#sec-3-7">3.7. Feature: parameter passing by value</a></li>
<li><a href="#sec-3-8">3.8. Feature: parameter passing by reference</a></li>
<li><a href="#sec-3-9">3.9. Remark: on side effects</a></li>
<li><a href="#sec-3-10">3.10. Transformation: Procedures ⟶ Gotos &amp; Variables</a></li>
<li><a href="#sec-3-11">3.11. Recursion</a></li>
</ul>
</li>
<li><a href="#sec-4">4. ✪ Interlude: Garbage Collection</a>
<ul>
<li><a href="#sec-4-1">4.1. Question</a></li>
<li><a href="#sec-4-2">4.2. Question</a></li>
</ul>
</li>
<li><a href="#sec-5">5. Object-oriented programming</a>
<ul>
<li><a href="#sec-5-1">5.1. Coupling data and related code</a></li>
<li><a href="#sec-5-2">5.2. Encapsulation</a></li>
<li><a href="#sec-5-3">5.3. Inheritance</a></li>
<li><a href="#sec-5-4">5.4. Multiple-inheritance &amp; interfaces</a></li>
<li><a href="#sec-5-5">5.5. Forward reference: ``objects are poor man's ''</a></li>
<li><a href="#sec-5-6">5.6. <span class="todo TODO">TODO</span> Traits; Objects as fix-points (✪)</a></li>
</ul>
</li>
<li><a href="#sec-6">6. Functional programming</a>
<ul>
<li><a href="#sec-6-1">6.1. A bit of syntax</a></li>
<li><a href="#sec-6-2">6.2. Algebraic Types</a></li>
<li><a href="#sec-6-3">6.3. Abstracting over functions</a></li>
<li><a href="#sec-6-4">6.4. Paradigm: HOT!</a></li>
<li><a href="#sec-6-5">6.5. Meaning of Higher-Order functions</a></li>
<li><a href="#sec-6-6">6.6. Purity and its Consequences</a></li>
<li><a href="#sec-6-7">6.7. Continuations</a></li>
<li><a href="#sec-6-8">6.8. State</a></li>
<li><a href="#sec-6-9">6.9. ✪ The State Monad</a></li>
<li><a href="#sec-6-10">6.10. Laziness</a></li>
</ul>
</li>
<li><a href="#sec-7">7. Concurrent programming</a>
<ul>
<li><a href="#sec-7-1">7.1. Disclaimer: Concurrent programming ≠ Parallel programming</a></li>
<li><a href="#sec-7-2">7.2. Motivation: the world is concurrent</a></li>
<li><a href="#sec-7-3">7.3. Process</a></li>
<li><a href="#sec-7-4">7.4. Shared state (aka Concurrent + Imperative)</a></li>
<li><a href="#sec-7-5">7.5. Paradigm: Concurrent + Functional</a></li>
<li><a href="#sec-7-6">7.6. Channels</a></li>
<li><a href="#sec-7-7">7.7. Understanding the tradeoffs</a></li>
<li><a href="#sec-7-8">7.8. ✪ Some erlang peculiarities</a></li>
<li><a href="#sec-7-9">7.9. Exercise: remote procedure call.</a></li>
<li><a href="#sec-7-10">7.10. Concurrency via Continuations</a></li>
</ul>
</li>
<li><a href="#sec-8">8. Logic programming</a>
<ul>
<li><a href="#sec-8-1">8.1. Notion: Proposition</a></li>
<li><a href="#sec-8-2">8.2. Notion: Free variables, open and closed propositions</a></li>
<li><a href="#sec-8-3">8.3. Curry</a></li>
<li><a href="#sec-8-4">8.4. Paradigm</a></li>
<li><a href="#sec-8-5">8.5. Example: family tree</a></li>
<li><a href="#sec-8-6">8.6. Example: Map coloring</a></li>
<li><a href="#sec-8-7">8.7. Notion: ground terms</a></li>
<li><a href="#sec-8-8">8.8. Transformation: Functions to relations</a></li>
<li><a href="#sec-8-9">8.9. Unification</a></li>
<li><a href="#sec-8-10">8.10. Transformation: Relations to Functions</a></li>
<li><a href="#sec-8-11">8.11. Search in general</a></li>
</ul>
</li>
<li><a href="#sec-9">9. Outlook</a></li>
<li><a href="#sec-10">10. ✪ Postlude: Where to go from here?</a>
<ul>
<li><a href="#sec-10-1">10.1. Exam :)</a></li>
<li><a href="#sec-10-2">10.2. More features we did not discuss:</a></li>
<li><a href="#sec-10-3">10.3. Explore the paradigms you like!</a></li>
<li><a href="#sec-10-4">10.4. Invent your own paradigm!</a></li>
<li><a href="#sec-10-5">10.5. Translations "in the large"</a></li>
<li><a href="#sec-10-6">10.6. Formal study of Syntax, Types</a></li>
<li><a href="#sec-10-7">10.7. A lot more to read</a></li>
<li><a href="#sec-10-8">10.8. A master/candidate project on Programming Languages?</a></li>
</ul>
</li>
<li><a href="#sec-11">11. Local Words (ignore)</a></li>
</ul>
</div>
</div>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> ✪ What is a "programming paradigm"?</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> Definition</h3>
<div class="outline-text-3" id="text-1-1">
<p>
Paradigm: "A philosophical and theoretical framework of a scientific
school or discipline within which theories, laws, and generalizations
and the experiments performed in support of them are formulated;
broadly: a philosophical or theoretical framework of any kind"
</p>

<ul class="org-ul">
<li><a href="http://www.merriam-webster.com/dictionary/paradigm">http://www.merriam-webster.com/dictionary/paradigm</a>
</li>
<li><a href="http://en.wikipedia.org/wiki/Programming_paradigm">http://en.wikipedia.org/wiki/Programming_paradigm</a>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> Paradigms as "ways of organizing thought"</h3>
<div class="outline-text-3" id="text-1-2">
<pre class="example">
            Programming paradigm
                       =
The basic structuring of thought underlying the programming activity
</pre>

<p>
e.g.. when you think of a programming problem, what are you thinking of?
</p>

<ul class="org-ul">
<li>the sequence of actions to perform (first download the file, then
display it)
</li>
<li>how to divide the problem-space into sub-tasks (to compute the
spanning tree, i can divide the graph arbitrarily in two, and then
&#x2026;)
</li>
<li>what are the agents involved (sensors, a simulator, a renderer, &#x2026;)
</li>
<li>what data do we need to handle? do we need intermediate
representations? what are the relations between the different forms?
</li>
</ul>

<p>
Note that the same way of thinking is not adapted to all
problems. Hence, it is important to know many paradigms!
</p>
</div>

<ol class="org-ol"><li><a id="sec-1-2-1" name="sec-1-2-1"></a>To each paradigm corresponds a "(mental) model of the computer"<br  /><div class="outline-text-4" id="text-1-2-1">
<p>
How do you think of your computer?
</p>

<ul class="org-ul">
<li>A bunch of transistors? (Very hard to reason at this level&#x2026;)
</li>
<li>(∗) Memory + instructions (von Neumann model)
</li>
<li>(∗) Rewriting engine (substitution model)
</li>
<li>(evaluator of) Mathematical functions
</li>
<li>(∗) A network: a number of units of execution communicating with messages 
</li>
<li>(∗) A prover of theorems (search model)
</li>
<li>&#x2026;
</li>
</ul>

<p>
(∗) We will see these in the course.
</p>
</div>
</li>

<li><a id="sec-1-2-2" name="sec-1-2-2"></a>Quotes on the ability to think "big thoughts"<br  /><div class="outline-text-4" id="text-1-2-2">
<ul class="org-ul">
<li>Anecdote: MULTICS
</li>
<li>"Language as thought shaper", from <a href="http://soft.vub.ac.be/~tvcutsem/whypls.html">http://soft.vub.ac.be/~tvcutsem/whypls.html</a>

<p>
To quote Alan Perlis: "a language that doesn't affect the way you
think about programming, is not worth knowing."
</p>

<p>
The goal of a thought shaper language is to change the way a
programmer thinks about structuring his or her program. The basic
building blocks provided by a programming language, as well as the
ways in which they can (or cannot) be combined, will tend to lead
programmers down a "path of least resistance", for some unit of
resistance. For example, an imperative programming style is definitely
the path of least resistance in C. It's possible to write functional C
programs, but as C does not make it the path of least resistance, most
C programs will not be functional.
</p>

<p>
Functional programming languages, by the way, are a good example of
thought shaper languages. By taking away assignment from the
programmer's basic toolbox, the language really forces programmers
coming from an imperative language to change their coding habits. I'm
not just thinking of purely functional languages like
Haskell. Languages like ML and Clojure make functional programming the
path of least resistance, yet they don't entirely abolish
side-effects. Instead, by merely de-emphasizing them, a program
written in these languages can be characterized as a sea of
immutability with islands of mutability, as opposed to a sea of
mutability with islands of immutability. This subtle shift often makes
it vastly easier to reason about the program.
</p>

<p>
Erlang's concurrency model based on isolated processes communicating
by messages is another example of a language design that leads to
radically different program structure, when compared to mainstream
multithreading models. Dijkstra's "GOTO considered harmful" and
Hoare's Communicating Sequential Processes are pioneering examples of
the use of language design to reshape our thoughts on programming. In
a more recent effort, Fortress wants to steer us towards writing
parallel(izable) programs by default.
</p>

<p>
Expanding the analogy with natural languages, languages as thought
shapers are not about changing the vocabulary or the grammar, but
primarily about changing the concepts that we talk about. Erlang
inherits most of its syntax from Prolog, but Erlang's concepts
(processes, messages) are vastly different from Prolog's (unification,
facts and rules, backtracking). As a programing language researcher, I
really am convinced that language shapes thought.
</p>
</li>
</ul>
</div>
</li></ol>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="section-number-3">1.3</span> Paradigms and Languages</h3>
<div class="outline-text-3" id="text-1-3">
<p>
Paradigms are underpinned by programming language features.
</p>

<p>
"If you cannot formulate it, you can't think it"
</p>
</div>

<ol class="org-ol"><li><a id="sec-1-3-1" name="sec-1-3-1"></a>The big-bang of languages<br  /><div class="outline-text-4" id="text-1-3-1">

<div class="figure">
<p><img src="LangPop.png" alt="LangPop.png" /> 
</p>
</div>

<p>
(image credit: <a href="http://redmonk.com/sogrady/2012/02/08/language-rankings-2-2012/">http://redmonk.com/sogrady/2012/02/08/language-rankings-2-2012/</a>)
</p>

<ul class="org-ul">
<li>In the old days: languages were built around a central idea,
crystallized in a paradigm.
</li>
<li>Explosion in the number of languages
</li>
<li>Now, there is a lot of cross-fertilization between
languages: real-world languages implement apparently random collections
of features.
</li>
<li>A given paradigm needs a specific set of features to be supported.
</li>
</ul>

<p>
The situation is summed up in <a href="paradigmsDIAGRAMeng.pdf">this diagram</a>
</p>

<p>
See also: <a href="http://langpop.com/">http://langpop.com/</a>
</p>
</div>
</li>

<li><a id="sec-1-3-2" name="sec-1-3-2"></a>PL Features we will see<br  /><div class="outline-text-4" id="text-1-3-2">
<ul class="org-ul">
<li>Structured data / Records
</li>
<li>Procedure
</li>
<li>Recursion
</li>
<li>Naming and abstraction (higher order)
</li>
<li>Memory (cell) / State
</li>
<li>Processes
</li>
<li>Communication channels
</li>
<li>Unification
</li>
<li>Search
</li>
</ul>
</div>
</li></ol>
</div>

<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4"><span class="section-number-3">1.4</span> Fluidity between paradigms</h3>
<div class="outline-text-3" id="text-1-4">
<p>
As a working programmer, you will often look at a program and think:
"this is a big mess". Your problem is to make sense of this
mess. Perhaps the code was written using the "wrong" paradigm; perhaps
the features to support the paradigms are not available to the
programmers, and they used a wrong method for the implementation.
</p>

<ul class="org-ul">
<li>We will learn to properly encode features using others
</li>
<li>By doing so we will also learn to recognize "a mess" as an encoding
of some feature(s) into others.
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5"><span class="section-number-3">1.5</span> ✪ A remark on paradigm shift</h3>
<div class="outline-text-3" id="text-1-5">
<p>
After writing many programs, you may notice patterns emerging. These
patterns may become codified, either informally (cf. "Design
Patterns", the seminal book) or formally within the language
(cf. Haskell type-classes).
</p>

<p>
Eventually, all programming may revolve around a number of patterns;
the old ways are abandoned.  This is the paradigm shift: a new way of
thinking appears. Eventually, a new programming language may be
developed to support the "patterns" directly.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Prelude: Abstraction and Types</h2>
<div class="outline-text-2" id="text-2">
<p>
Types are essential to get a quick overview of what a program is
"about". Very useful when facing unknown programs! We use them a lot in
this course to structure the thinking about programs.
</p>

<p>
The colon ':' is used to denote the typing relation:
</p>

<pre class="example">
someValue : ItsType
</pre>
</div>

<ol class="org-ol"><li><a id="sec-2-0-1" name="sec-2-0-1"></a>Examples<br  /><div class="outline-text-4" id="text-2-0-1">
<ul class="org-ul">
<li>0 : Int
</li>
<li>1 : Int
</li>
<li>1 : Natural
</li>
<li>'c' : Char
</li>
<li>"hello" : String
</li>
<li>0.5 : Float
</li>
<li>(1/2) : Rational
</li>
</ul>
</div>
</li>

<li><a id="sec-2-0-2" name="sec-2-0-2"></a>Feature: naming things<br  /><div class="outline-text-4" id="text-2-0-2">
<p>
One could write a program to compute the area of the floor of the
copper-dome as follows, assuming the floor is a circle of radius 20
meter.
</p>

<p>
area = 20 * 20 * 3.141592
</p>

<p>
It is error-prone to write the radius multiple times. (if someone were
to give a better measure for the radius, or a better approximation for
π, I might forget to update one of the instances in the program.)
Furthermore it might be useful to give a meaningful name to the
value. Hence most programming languages allow you to write:
</p>

<pre class="example">
radius = 20
pi = 3.141592
area = radius * radius * pi
</pre>
</div>
</li>

<li><a id="sec-2-0-3" name="sec-2-0-3"></a>Feature: Parametrization and function types<br  /><div class="outline-text-4" id="text-2-0-3">
<p>
Now is a good time to see our first programming language feature. This
feature is so ubiquitous that nearly every language has it. (Can you
think of a counter-example?). In fact, you may not have thought of it
as a "feature" at all so far. We are talking about the ability to
<i>abstract</i> over parameters.
</p>


<p>
Consider a simple value like this:
</p>

<pre class="example">
greetMe : String
greetMe = "Hello, Jean-Philippe! How are you today?"
</pre>


<p>
That's very useless as a program! We want to be able to greet more
than one person. To do so, we should and parametrize (or abstract)
over the name of the person greeted.
</p>

<p>
As an intermediate step, let us name the part we wish to abstract over:
</p>


<pre class="example">
name = "Jean-Philippe"
greet = "Hello, " ++ name ++ "! How are you today?"
</pre>


<p>
Now, we can leave the name abstract. (Most programming languages
require the programmer to mark abstract things explicitly. In this
example we write the parameter inside parentheses):
</p>

<pre class="example">
greet(name) = "Hello, " ++ name ++ "! How are you today?"
</pre>


<p>
When using abstraction, programs get more complicated. In particular,
it might not be so clear that <i>every</i> value can be used for the
parameter.  What if <code>name</code> is a floating point number? In this simple
example it is pretty obvious, but in reality things get hairy pretty
fast.
</p>

<p>
In our example, we may declare that the above code makes sense only
when <code>name</code> is a string (more precisely <i>any</i> string); and in that
case <code>greet(name)</code> is also a string.  Equivalently, we will say that
<code>greet</code> is a function converting a string into another string, and we
will write:
</p>

<pre class="example">
greet : String → String
</pre>


<p>
The flip side of abstraction is application (or use). Given an
abstract piece of code, one can use it as many times as desired on
concrete cases.
</p>

<pre class="example">
greet "dog"
greet "there children!"
</pre>

<p>
Philosophical remark: if there is no application possible; abstraction
is useless &#x2014; so they really are two sides of the same coin.
</p>

<p>
Benjamin Pierce's "Good Language" test: Can you abstract over
everything you can name?
</p>
</div>
</li>

<li><a id="sec-2-0-4" name="sec-2-0-4"></a>Aside: Functions as a sepcial kind of relations?<br  /><div class="outline-text-4" id="text-2-0-4">
<p>
(Will be revisited when we see logic programming)
You may have encountered the arrow notation for types earlier in your
studies, in the context of maths. Usually, math is built on top of set
theory, and hence functions are defined as a special kind of
relation. (We will revist this idea in the chapter on logic
programming.)
</p>

<p>
However, in this course, we take the view that arrow (function) type
is a primitive (foundational) notion, based on the intuition discussed above.
</p>
</div>
</li>
<li><a id="sec-2-0-5" name="sec-2-0-5"></a>Exercises: types of the following<br  /><div class="outline-text-4" id="text-2-0-5">
<ol class="org-ol">
<li>factorial : ?
</li>
<li>π : ?
</li>
<li>sin : ?
</li>
<li>× : ?   (multiplication)
</li>
<li>derivative : ? (or ∫ : ?) (review this question after FP paradigm&#x2026;)
<ul class="org-ul">
<li>hint: remember that derivative maps sin to cos.
</li>
</ul>
</li>
</ol>
<p>
(answers given in exercise sheet)
</p>
</div>
</li>

<li><a id="sec-2-0-6" name="sec-2-0-6"></a>Model: substitution<br  /><ol class="org-ol"><li><a id="sec-2-0-6-1" name="sec-2-0-6-1"></a>The meaning of application is substitution.<br  /><div class="outline-text-5" id="text-2-0-6-1">
<p>
area 20 ⟶ (\r -&gt; r * r * pi) 20
        ⟶ 20 * 20 * pi
        ⟶ 400 * pi
        ⟶ &#x2026;
</p>
</div>
</li>

<li><a id="sec-2-0-6-2" name="sec-2-0-6-2"></a>remember 'inlining'<br  /><div class="outline-text-5" id="text-2-0-6-2">
<p>
inlining usually means 'substitution' of the reference by its value.
</p>
</div>
</li>
<li><a id="sec-2-0-6-3" name="sec-2-0-6-3"></a>pitfall: name-capture<br  /><div class="outline-text-5" id="text-2-0-6-3">
<p>
Example:
</p>

<p>
area r = let r2 = r * r in r * pi
</p>

<p>
ringArea r1 r2 = area r2 - area r2
</p>

<p>
To avoid name-capture (or any kind of side-effect) evaluate the
arguments first!
</p>
</div>
</li>
<li><a id="sec-2-0-6-4" name="sec-2-0-6-4"></a>Programmatically<br  /><div class="outline-text-5" id="text-2-0-6-4">
<p>
<a href="Final/Fun.hs">Final/Fun.hs</a>
</p>
</div>
</li></ol>
</li>
<li><a id="sec-2-0-7" name="sec-2-0-7"></a>✪ Teaser: Higher-order abstraction<br  /><div class="outline-text-4" id="text-2-0-7">
<p>
Will be revisited when we see functional programming.
</p>

<p>
"What can be named/abstracted on" is an important characteristic of
programming languages. Consider you favorite programming
language. Does it support abstraction over:
</p>
<ul class="org-ul">
<li>integers?
</li>
<li>characters?
</li>
<li>strings?
</li>
<li>arrays?
</li>
<li>matrices?
</li>
<li>blocks of code?
</li>
<li>functions?
</li>
<li>types?
</li>
<li>modules?
</li>
<li>&#x2026;
</li>
</ul>

<p>
Higher-order functions refer to functions which are parametrized by
other functions.
</p>

<p>
Higher-order abstraction is useful because
</p>
<ul class="org-ul">
<li>it is theoretically as powerful as possible (Every other feature can
be reduced to higher order abstraction)
</li>
<li>it is very useful in practice, as we shall see in the chapter on
functional programming.
</li>
</ul>

<p>
Typically in mathematics abstraction is
unrestricted. Consider for example the types of derivative and
integrals!
</p>
</div>

<ol class="org-ol"><li><a id="sec-2-0-7-1" name="sec-2-0-7-1"></a>✪ Every problem can be solved by adding a level of indirection<br  /><div class="outline-text-5" id="text-2-0-7-1">
<p>
"All problems in computer science can be solved by another level of indirection" &#x2014; Butler Lampson
</p>

<p>
My version: every problem can be solved by adding a level of abstraction.
</p>
</div>
</li></ol>
</li></ol>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Imperative programming</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> Model: von Neumann computer</h3>
<div class="outline-text-3" id="text-3-1">
<p>
"von Neumann" model of the computer:
</p>

<ul class="org-ul">
<li>Memory cells
</li>
<li>Program (assignments, arithmetic, logic, (conditional) jumps)
</li>
</ul>

<p>
This is similiar to what you may find in a cookbook:
</p>

<p>
Ingredients:
</p>
<ul class="org-ul">
<li>Pasta
</li>
<li>Water
</li>

<li>Boil water
</li>
<li>Throw pasta in water
</li>
<li>Taste
</li>
<li>if too hard, then goto 2.
</li>
</ul>

<p>
(cf. cookbook&#x2026; for beginner cooks :)
</p>
</div>
<ol class="org-ol"><li><a id="sec-3-1-1" name="sec-3-1-1"></a>Programmatically<br  /><div class="outline-text-4" id="text-3-1-1">
<p>
<a href="Final/VM.hs">Final/VM.hs</a>
</p>
</div>
</li>
<li><a id="sec-3-1-2" name="sec-3-1-2"></a>Model: Turing machine<br  /><div class="outline-text-4" id="text-3-1-2">
<p>
An idealised version of the von Neumann computer is the "Turing
Machine" (invented by Alan Turing).  The memory of the turing machine
consist of an infinitely-long 1-dimensional tape divided into
equal-size pieces each containing one bit.
</p>

<p>
The "computing" is performed by a transition function from the
internal state of the machine, and the current symbol on the tape, to
a new state and an instruction, which can be either to move the tape
or write a symbol (bit) at the current position.
</p>

<p>
This extremely idealised machine is interesting from a theoretical
viewpoint, because it is at least powerful as the von Neumann
computer, while being even simpler. Furthermore, any computer (and any
programming interface built on top of it) can be reduced to a Turing
machine.
</p>

<p>
A programming language is said to be "Turing-complete" if one can do
as much as a Turing machine in it.
</p>
</div>
</li></ol>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> Example: Sorting</h3>
<div class="outline-text-3" id="text-3-2">
</div><ol class="org-ol"><li><a id="sec-3-2-1" name="sec-3-2-1"></a>Feature: GOTO<br  /><div class="outline-text-4" id="text-3-2-1">
<p>
A pretty basic feature of imperative language is the jump (also known
as "GOTO").  A goto is an instruction to jump to a particular point in
the program. Sometimes, a contition is associated with the jump: the
jump is performed only if the condition is true.
</p>

<p>
Based on your understanding of GOTO, try to figure out what the
following code does. Do you find it easy to understand? In the next
section we will propose an improvement.
</p>
<pre class="example">
-- Assume A : array of comparable items

begin:
     swapped = false
     i := 1;
loop:
     if A[i-1] &lt;= A[i] goto no_swap
     swap( A[i-1], A[i] )
     swapped = true
no_swap:
     i := i+1
     if i &lt; n then goto loop
     if swapped goto begin
</pre>
</div>
</li>

<li><a id="sec-3-2-2" name="sec-3-2-2"></a>Feature: Loops &amp; Ifs<br  /><div class="outline-text-4" id="text-3-2-2">
<p>
It has been noted that programs written using only gotos in arbitrary
ways are pretty hard to understand. (One sometimes refers to this sort
of programs as "spaghetti code")
</p>

<p>
Therefore, usage of gotos should be restricted to a few easy patterns
(loops; or conditional execution). Nowadays gotos have almost
disappeared from usage and all code is written using special-purpose
instructions for the above patterns. This is an instance of paradigm
shift.
</p>

<p>
Here is a program doing the same as the above, but using only loops
and if. Is it easier to understand?
</p>
<pre class="example">
-- Assume A : array of comparable items

   swapped = true
   while swapped
     swapped = false
     for each i in 1 to length(A) - 1 inclusive do:
       if A[i-1] &gt; A[i] then
         swap( A[i-1], A[i] )
         swapped = true
       end if
     end for
</pre>
</div>
</li>

<li><a id="sec-3-2-3" name="sec-3-2-3"></a>Feature: procedures<br  /><div class="outline-text-4" id="text-3-2-3">
<p>
The above code is parametric over the array <code>A</code>. If the language
supports abstraction over arrays we should take advantage of it and
present the above program as a procedure.
</p>
<pre class="example">
procedure bubbleSort( A : array of comparable items )
  swapped = true
  while swapped
    swapped = false
    for each i in 1 to length(A) - 1 inclusive do:
      if A[i-1] &gt; A[i] then
        swap( A[i-1], A[i] )
        swapped = true
      end if
    end for
  end
end procedure
</pre>
</div>
</li>

<li><a id="sec-3-2-4" name="sec-3-2-4"></a>Extra reading<br  /><div class="outline-text-4" id="text-3-2-4">
<p>
It has not always been clear that GOTO was a bad idea. Dijkstra is
perhaps the famous opponent of GOTO:
</p>

<p>
<a href="http://portal.acm.org/citation.cfm?id=362947">GOTO statement considered harmful</a>, E. G. Dijkstra
</p>
</div>
</li></ol>
</div>

<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3"><span class="section-number-3">3.3</span> Transformation: Loops ⟶ Gotos</h3>
<div class="outline-text-3" id="text-3-3">
<p>
The pattern in this course will be to understand a feature by
<i>translation</i> into other, known features. To get warmed up, we will do
so with a feature we already understand well; namely loops.
</p>
</div>

<ol class="org-ol"><li><a id="sec-3-3-1" name="sec-3-3-1"></a>Source<br  /><div class="outline-text-4" id="text-3-3-1">
<p>
Consider the following loop:
</p>
<pre class="example">
while i &gt; 0 do
  a[i] := b[i]
  i := i-1
</pre>
</div>
</li>

<li><a id="sec-3-3-2" name="sec-3-3-2"></a>Target<br  /><div class="outline-text-4" id="text-3-3-2">
<p>
It can be encoded into the following code, which uses only
(conditional) jumps:
</p>
<pre class="example">
test:
  p := not (i&gt;0)
  if p then goto done
  a[i] := b[i]
  i = i-1
  goto test
done:
</pre>



<p>
Note in passing that such a job is typically performed by a C (or
Java&#x2026;) compiler. Indeed, the computer code has no notion of loop, it
only knows about jumps.
</p>
</div>
</li>

<li><a id="sec-3-3-3" name="sec-3-3-3"></a>Feature: do &#x2026; until<br  /><div class="outline-text-4" id="text-3-3-3">
<pre class="example">
do
   body
until cond
</pre>

<p>
is translated to
</p>

<pre class="example">
loop:
   body
   if not (cond) goto loop;
</pre>

<p>
In fact the above transformation is parametric on the
condition and body of the loop. Hence we may just abstract over these
parts. We will present the next transformation in this format.
</p>
</div>
</li>

<li><a id="sec-3-3-4" name="sec-3-3-4"></a>In-class exercise: insertion sort<br  /><div class="outline-text-4" id="text-3-3-4">
<div class="org-src-container">

<pre class="src src-c">#include &lt;stdio.h&gt;

void sort (int a[], int n) {
  int i,j;
  for (i=1; i&lt;n; i++) {
    // invariant: the array is sorted up to and excluding i.
    int tmp = a[i];
    j = i;
    /* printf ("Iteration i=%d, tmp=%d\n", i, tmp); */
    while (j &gt; 0 &amp;&amp; tmp &lt; a[j-1]) {
      // invariant: tmp is smaller than a[j] to a[i+1]
      a[j] = a[j-1];
      j = j-1;
    }
    a[j] = tmp;
  }
}

int input[9] = {34,23,435,124,5,4,1235,123,4};

int main () {
  sort(input,9);
  int i;
  for (i=0;i&lt;9;i++)
    printf("%d\n",input[i]);
  return 0;
}
</pre>
</div>

<div class="org-src-container">

<pre class="src src-c">#include &lt;stdio.h&gt;

void sort (int a[], int n) {
  int i,j;
  i = 1;
 loop:
  if (! (i&lt;n)) goto loopEnd;
  // invariant: the array is sorted up to and excluding i.
  int tmp = a[i];
  j = i;
  /* printf ("Iteration i=%d, tmp=%d\n", i, tmp); */
 innerLoop:
  if (!(j &gt; 0 &amp;&amp; tmp &lt; a[j-1]))
    goto innerLoopEnd;
  // invariant: tmp is smaller than a[j] to a[i+1]
  a[j] = a[j-1];
  j = j-1;
  goto innerLoop;
 innerLoopEnd:
  a[j] = tmp;
  i++;
  goto loop;
 loopEnd:
}

int input[9] = {34,23,435,124,5,4,1235,123,4};

int main () {
  sort(input,9);
  int i;
  for (i=0;i&lt;9;i++)
    printf("%d\n",input[i]);
  return 0;
}
</pre>
</div>
</div>
</li></ol>
</div>
<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4"><span class="section-number-3">3.4</span> Transformation: If then else ⟶ Gotos</h3>
<div class="outline-text-3" id="text-3-4">
</div><ol class="org-ol"><li><a id="sec-3-4-1" name="sec-3-4-1"></a>Source<br  /><div class="outline-text-4" id="text-3-4-1">
<p>
Assuming a Boolean-valued expression <code>cond</code> and two blocks of code
<code>part1</code> and <code>part2</code>, and the following pattern:
</p>
<pre class="example">
if cond then
  part1
else
  part2
</pre>
</div>
</li>
<li><a id="sec-3-4-2" name="sec-3-4-2"></a>Target<br  /><div class="outline-text-4" id="text-3-4-2">
<p>
It can be translated into:
</p>
<pre class="example">
  p := not(cond)
  goto label2 when p is true
  part1
  goto done
label2:
  part2
done:
</pre>
</div>
</li>
<li><a id="sec-3-4-3" name="sec-3-4-3"></a>Computed jumps<br  /><div class="outline-text-4" id="text-3-4-3">
<p>
Most computers also feature computed (indirect) jumps. That is, one
does not jump to a fixed label, but to a variable one. This is once
more an example of abstraction: the computed goto is a goto which is
"abstract" over its target.
</p>

<p>
For example using a computed jump one may translate <code>if</code> as follows:
</p>
<pre class="example">
if cond then
  target = label1;
else
  target = label2;
goto target
label1:
  part1
  goto done
label2:
  part2
end
done:
</pre>
<p>
Can you figure out the type of the <code>target</code> variable? (Answer: pointer to code)
</p>

<p>
Remark: Computed jumps are not present in C or C++.
</p>
</div>
</li>
<li><a id="sec-3-4-4" name="sec-3-4-4"></a>Remark: goto+if vs. conditional jump<br  /><div class="outline-text-4" id="text-3-4-4">
<p>
It is trivial to convert back and forth between an if statement with a
single goto in the body and a conditional jump, so we consider them
equivalent in this course.
</p>
</div>
</li></ol>
</div>

<div id="outline-container-sec-3-5" class="outline-3">
<h3 id="sec-3-5"><span class="section-number-3">3.5</span> Reverse transformation: (Gotos ⟶ Loops)</h3>
<div class="outline-text-3" id="text-3-5">
<p>
The reverse transformation (from jumps to structured constructions) is
not so easy. That is, there is no general formula that gives you
structured/"beautiful" code from "spaghetti" code made up of arbitrary
gotos. Inventing a beautiful structure requires a creative leap!  A
good first step is to try to recognize the patterns generated above
and reconstruct the source from them&#x2026; But it fails on true
spaghetti code.
</p>
</div>
</div>
<div id="outline-container-sec-3-6" class="outline-3">
<h3 id="sec-3-6"><span class="section-number-3">3.6</span> Transformation: inlining procedure calls</h3>
<div class="outline-text-3" id="text-3-6">
<p>
This is the reverse of naming code blocks.
</p>
</div>
<ol class="org-ol"><li><a id="sec-3-6-1" name="sec-3-6-1"></a>Source<br  /><div class="outline-text-4" id="text-3-6-1">
<pre class="example">
procedure g(by ref. x,y)
  x := x + y

procedure f(by ref. x,y)
  g(x,y)
  x := x + 1
  g(y,x)

f(a,b)
</pre>
</div>
</li>
<li><a id="sec-3-6-2" name="sec-3-6-2"></a>Intermediate<br  /><div class="outline-text-4" id="text-3-6-2">
<pre class="example">
procedure f(x,y)
  x := x + y
  x := x + 1
  y := y + x


f(a,b)
</pre>
</div>
</li>

<li><a id="sec-3-6-3" name="sec-3-6-3"></a>Final<br  /><div class="outline-text-4" id="text-3-6-3">
<pre class="example">
a := a + b
a := a + 1
b := b + a
</pre>
</div>
</li></ol>
</div>

<div id="outline-container-sec-3-7" class="outline-3">
<h3 id="sec-3-7"><span class="section-number-3">3.7</span> Feature: parameter passing by value</h3>
<div class="outline-text-3" id="text-3-7">
<p>
Passing a parameter by value is equivalent to making a <i>copy</i> of the
parameter before passing it to the function procedure.
</p>

<p>
This means that, if the function/procedure updates the parameter, the
argument remains untouched at the call site.
</p>

<p>
This is what happens in C (pitfall: arrays) and (by defaut) in C++.
</p>

<div class="org-src-container">

<pre class="src src-C">void updateOrNot(int x) {
  x = 12;
}

int main(void) {
  int x = 56;
  updateOrNot(x);
  return x;
}

// use echo $? to see the result

// substitution model meaning?
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-8" class="outline-3">
<h3 id="sec-3-8"><span class="section-number-3">3.8</span> Feature: parameter passing by reference</h3>
<div class="outline-text-3" id="text-3-8">
</div><ol class="org-ol"><li><a id="sec-3-8-1" name="sec-3-8-1"></a>Example<br  /><div class="outline-text-4" id="text-3-8-1">
<div class="org-src-container">

<pre class="src src-cpp">#include &lt;stdio.h&gt;

void updateOrNot(int &amp;y) {
  y = 12;
}

int main(void) {
  int x = 56;
  updateOrNot(x);
  printf("%d\n",x);
  return x;
}

// use echo $? to see the result

// substitution model meaning?
// von neumann model meaning?
</pre>
</div>
</div>
</li>
<li><a id="sec-3-8-2" name="sec-3-8-2"></a>Meaning in the substitution model<br  /><div class="outline-text-4" id="text-3-8-2">
<p>
Consider a declaration of the procedure 'swap' together with a number of calls:
</p>
<pre class="example">
procedure swap(by reference x, by reference y)
  local var tmp;
  tmp := y;
  y := x;
  x := tmp;
</pre>

<pre class="example">
swap(x,y)
...
...
swap(x,y)
...
...
swap(x,z)
</pre>

<p>
It is equivalent to the following program:
</p>

<pre class="example">
tmp := x;
y := x;
x := tmp;
...
...
tmp := x;
y := x;
x := tmp;
...
...
tmp := x;
z := x;
x := tmp;
</pre>

<p>
In other words: if parameters are passed by reference, calling the
function/procedure is equivalent to copying its body at the call
site. (pitfall: name capture; side effects)
</p>
</div>
</li>
<li><a id="sec-3-8-3" name="sec-3-8-3"></a>Why is passing by reference useful?<br  /><div class="outline-text-4" id="text-3-8-3">
<ul class="org-ul">
<li>Passing by reference means that the programmer can name <i>blocks of
code</i>.
</li>
<li>"expressive power" : you can factor out parts of the computation
that update any (sub-part of) the state
</li>
<li>save time : no need to copy around things
</li>
</ul>
</div>
</li>

<li><a id="sec-3-8-4" name="sec-3-8-4"></a>Reminder: References (aka. pointers)<br  /><ol class="org-ol"><li><a id="sec-3-8-4-1" name="sec-3-8-4-1"></a>Example<br  /><div class="outline-text-5" id="text-3-8-4-1">
<div class="org-src-container">

<pre class="src src-C">#include &lt;stdio.h&gt;

int x = 777;
int y = 888;

int* p = &amp;x;

int main () {
  printf("%lx\n", (long) &amp;p);
  printf("%d\n", *p);
  return 0;
}
</pre>
</div>
</div>
</li>
<li><a id="sec-3-8-4-2" name="sec-3-8-4-2"></a>Addresses<br  /><div class="outline-text-5" id="text-3-8-4-2">
<p>
Assume a variable x:
</p>

<pre class="example">
x : Integer {-Variable -}
x : int;
</pre>

<p>
Then
</p>

<pre class="example">
addressOf(x) : PointerTo Integer
&amp;x           : int*;
</pre>
<p>
≃ where in the memory is the variable x
</p>

<p>
We could express this with the following typing for <code>addressOf</code>:
</p>
<pre class="example">
addressOf : Integer {-By Ref-} → PointerTo Integer
</pre>
</div>
</li>

<li><a id="sec-3-8-4-3" name="sec-3-8-4-3"></a>"De-reference"<br  /><div class="outline-text-5" id="text-3-8-4-3">
<pre class="example">
variableAt : PointerTo Integer → Integer
</pre>
<p>
or
</p>
<pre class="example">
p : Integer ⊢ variableAt(p) : Integer
</pre>

<p>
or, borrowing some C syntax
</p>

<pre class="example">
p : int ⊢ *p : int
</pre>
</div>
</li>

<li><a id="sec-3-8-4-4" name="sec-3-8-4-4"></a>Trivia: whats the meaning of addressOf(addressOf(x))?<br  /><div class="outline-text-5" id="text-3-8-4-4">
<p>
none! because addressOf(x) is just a value, there is no location for it in the memory.
</p>
</div>
</li></ol>
</li>
<li><a id="sec-3-8-5" name="sec-3-8-5"></a>Translation: from reference-parameters to pointers<br  /><div class="outline-text-4" id="text-3-8-5">
<p>
We can give a meaning to reference parameters in the von Neumann model
as well, by using pointers.
</p>
</div>


<ol class="org-ol"><li><a id="sec-3-8-5-1" name="sec-3-8-5-1"></a>Source:<br  /><div class="outline-text-5" id="text-3-8-5-1">
<p>
(Supposing the language supports passing arguments by reference:)
</p>

<pre class="example">
procedure increment(by ref. x : Int)
  x := x + 1
</pre>
<p>
with a call
</p>
<pre class="example">
increment(y)
</pre>


<p>
or in C++ syntax:
</p>

<pre class="example">
void increment(int &amp;x) {
  x = x+1;
}
</pre>
<p>
with a call
</p>
<pre class="example">
increment(y);
</pre>
</div>
</li>

<li><a id="sec-3-8-5-2" name="sec-3-8-5-2"></a>Target<br  /><div class="outline-text-5" id="text-3-8-5-2">
<p>
(Assuming the language supports pointers:)
</p>

<pre class="example">
increment(x : PointerTo Int)
 variableAt(x) := variableAt(x) + 1
</pre>
<p>
and the call
</p>
<pre class="example">
increment(addressOf(y))
</pre>

<p>
or in C syntax:
</p>

<pre class="example">
void increment(int *x) {
  *x = *x+1;
}
</pre>
<p>
with a call
</p>
<pre class="example">
increment(&amp;y);
</pre>
</div>
</li></ol>
</li>

<li><a id="sec-3-8-6" name="sec-3-8-6"></a>Exercise: Does Java use call by reference?<br  /><div class="outline-text-4" id="text-3-8-6">
<p>
Show example(s) that says yes or no (see exercise sheet for an answer)
</p>
</div>
</li></ol>
</div>
<div id="outline-container-sec-3-9" class="outline-3">
<h3 id="sec-3-9"><span class="section-number-3">3.9</span> Remark: on side effects</h3>
<div class="outline-text-3" id="text-3-9">
<p>
When inlining a function, one may duplicate the arguments (or place
them somewhere else in the code); and so one must wonder whether
inlining will duplicate the side-effects associated with these
arguments.
</p>

<p>
In the by-value case, even if there were side effects in the
arguments, inlining will not duplicate them since we have to first
copy their value to a temporary variable.
</p>

<p>
In the by-reference case, the situation is more complex. In most
cases, the argument won't have a side effect since it must be a memory
location. If the argument is an effectful expression computing a
memory location, then we must use the translation to pointers before
inlining.
</p>

<p>
To be safe: evaluate the arguments before inlining.
</p>
</div>
</div>
<div id="outline-container-sec-3-10" class="outline-3">
<h3 id="sec-3-10"><span class="section-number-3">3.10</span> Transformation: Procedures ⟶ Gotos &amp; Variables</h3>
<div class="outline-text-3" id="text-3-10">
<p>
Source:
</p>
<pre class="example">
function sqrt(x : Float) : Float
  result := x / 2
  while distance (result * result, x) &gt; ε
    -- Newton approx to refine the result
    ...
  return result;

-- the calls:
sqrt(12345);
...
...
sqrt(6789);
</pre>

<p>
Target:
</p>
<pre class="example">
sqrt:
-- argument in global variable 'sqrtArgument'
sqrtResult := sqrtArgument / 2;
-- And then newton algorithm 
...
...
-- at this point, sqrtResult contains the result.
goto sqrtCaller;

sqrtArgument := 12345;
sqrtCaller := out1;
goto sqrt;
out1:
...
...
sqrtArgument := 6789;
sqrtCaller := out2;
goto sqrt;
out2:
</pre>

<p>
In sum, the translation of a call is:
</p>
<ol class="org-ol">
<li>copy the arguments to the variables corresponding to the
parameters;
</li>
<li>save the return address in a variable;
</li>
<li>goto the procedure's code.
</li>
</ol>

<p>
At the end of the procedure/function, one must
</p>
<ul class="org-ul">
<li>put the result in a global variable. (if applicable)
</li>
<li>add an explicit jump to the caller.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-11" class="outline-3">
<h3 id="sec-3-11"><span class="section-number-3">3.11</span> Recursion</h3>
<div class="outline-text-3" id="text-3-11">
</div><ol class="org-ol"><li><a id="sec-3-11-1" name="sec-3-11-1"></a>Understanding recursion using the substitution model<br  /><div class="outline-text-4" id="text-3-11-1">
<p>
Start:
</p>
<pre class="example">
procedure fib(int x)
  if x &lt;= 1 then
    return 1;
  else
    tmp := fib (x-1)
    return tmp + fib(x-2);
</pre>
<p>
Inlining the 1st procedure call:
</p>
<pre class="example">
procedure fib(int x)
  if x &lt;= 1 then
    return 1;
  else
    if x-1 &lt;= 1 then
      return 1;
    else
      tmp2 := fib (x-2)
      tmp := tmp2 + fib(x-3);
    return tmp + fib(x-2);
</pre>

<p>
We end up with more calls than we started! The process never finishes!
</p>

<p>
As a model for procedure calls, inlining/substitution is
</p>
<ul class="org-ul">
<li>OK as a dynamic model: it works on concrete programs. For example
expanding <code>fib(5)</code> eventually terminates to a concrete integer
</li>
<li>Not OK as a static model in the presence of recursion, unless one
understands infinite programs.
</li>
</ul>
</div>
</li>
<li><a id="sec-3-11-2" name="sec-3-11-2"></a>Transformation: Recursion ⟶ Explicit stack<br  /><div class="outline-text-4" id="text-3-11-2">
<p>
In case of a recursive call, the steps 1. and 2. above are
problematic. Indeed, they will overwrite the previous value! Hence one
must use a new location each time: use a stack.
</p>

<p>
The translation of a call then becomes:
</p>

<ol class="org-ol">
<li>push the arguments to the variables corresponding to the
parameters on a stack;
</li>
<li>push the return address;
</li>
<li>goto the procedure's code.
</li>
<li>pop
</li>
</ol>

<p>
&#x2026; and the translation of the procedure/function must access its
parameters/return address on the stack.
</p>

<p>
(note that the result may remain a global: it is not used in the body
of the function)
</p>
</div>

<ol class="org-ol"><li><a id="sec-3-11-2-1" name="sec-3-11-2-1"></a>Example: factorial.<br  /><div class="outline-text-5" id="text-3-11-2-1">
<p>
The following example shows step-by-step how to transform recursion to
jumps+stack.
</p>

<div class="org-src-container">

<pre class="src src-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;


struct stack{
  int x;
  int caller;
  struct stack* next;
};

typedef struct stack* stk;

stk s = NULL;

void push(int x,int ret) {
  stk t = malloc(sizeof (struct stack));
  t-&gt;x = x;
  t-&gt;caller = ret;
  t-&gt;next = s;
  s = t;
}

void pop() {
  s = s-&gt;next;
}

// original
int fact1 (int x) {
  if (x == 1)
    return x;
  else
    return x * fact1(x-1);
}

// make order of eval. explicit
int fact2 (int x) {
  int tmp;
  if (x == 1)
    return x;
  else {
    tmp = fact2(x-1);
    return x * tmp;
  }
}

// put result in a global var
int result;

int fact3 (int x) {
  int tmp;
  if (x == 1)
    result = x;
  else {
    fact3(x-1);
    tmp = result;
    result = x * tmp;
  }
  return result;
}

// put arguments on a stack
void fact4() {
  if (s-&gt;x == 1)
    result = 1;
  else {
    push(s-&gt;x-1,0);
    fact4();
    pop();
    result = s-&gt;x * result;
  }
}

// put the return address on the stack and do the jumps by hand
void fact5() {
 fact5:
  if (s-&gt;x == 1)
    result = 1;
  else {
    push(s-&gt;x-1,1);
    goto fact5;
  lab1:
    pop();
    result = s-&gt;x * result;
  }
  if (s-&gt;caller == 1) goto lab1;
}


// put the stack initialisation in the function
int fact6 (int x) {
  push(x,0 /* 0 represents top-level call */);
 start:
  if (s-&gt;x == 1) {
    result = 1;
  }
  else {
    /* result = fact(x-1); */
    push(s-&gt;x-1,1 /* 1 represents the recursive call */);
    goto start;
  lab1:
    pop();
    result = s-&gt;x * result;
  }
  /* goto s-&gt;caller; (invalid C; we must encode it)*/
  if (s-&gt;caller == 1)
    goto lab1;
  return result;
}

// re-construct loops
int fact7 (int x) {
  push(x,0 /* 0 represents top-level call */);
  // !! not quite right: if s-&gt;x is == 1, return immediately
  while (!(s-&gt;x == 1)) {
    push(s-&gt;x-1,1 /* 1 represents the recursive call */);
  };
  result = 1;
  do {
    pop();
    result = s-&gt;x * result;
  } while (s-&gt;caller == 1);
  return result;
}

// 1. pre-work: make order of evaluation explicit
// 2. put result in a var
// 3.a use the stack instead of argument
// 3.b return address on the stack
// 3.c prologue/epilogue (push 1st stack frame)
// 4. transform the call into gotos
// 6. encode translate computed goto

int main(){
  printf("%d\n",fact7(10));
  return 0;
}
</pre>
</div>
</div>
</li></ol>
</li>

<li><a id="sec-3-11-3" name="sec-3-11-3"></a>Transformation: Tail Recursion ⟶ Loop<br  /><ol class="org-ol"><li><a id="sec-3-11-3-1" name="sec-3-11-3-1"></a>Transformation: tail-call elimination<br  /><div class="outline-text-5" id="text-3-11-3-1">
<p>
The pattern
</p>

<pre class="example">
  push (arguments,locals,caller)
  caller := continue
  goto fact
continue:
  pop (arguments,locals,caller);
  result := result // forward the result from the inner call
  goto caller
</pre>

<p>
can be optimised. Indeed:
</p>

<ul class="org-ul">
<li>The local variables are saved for nothing: they are not used after they are popped!
</li>
<li>The result := result statement is useless.
</li>
<li>In turn, saving the arguments, etc. is also useless, since one
jumps back to the caller immediately, where they will be popped
from the stack.
</li>
</ul>


<p>
Hence we obtain the pattern
</p>

<pre class="example">
  top_of_stack := (arguments,locals)
  push(caller);
  caller := continue
  goto fact
continue:
  pop(caller);
  goto caller
</pre>

<p>
(Another, simpler way to explain this optimisation is that the last call
can overwrite the previous values, since they will never be used again)
</p>

<p>
But the only thing we do after the call is to pop the caller and jump
back&#x2026;  So we might as well not jump to the piece of code labeled
<code>continue</code>, and let the caller do the cleanup job.
</p>

<pre class="example">
top_of_stack := (arguments,locals) // do not overwrite the pointer to the caller
goto fact
</pre>


<p>
This is called <a href="http://en.wikipedia.org/wiki/Tail_call">tail-call elimination</a>.
</p>

<p>
In the case of the factorial function, there are only tail calls, so
the stack can be removed altogether!
</p>
</div>
</li>

<li><a id="sec-3-11-3-2" name="sec-3-11-3-2"></a>Example<br  /><div class="outline-text-5" id="text-3-11-3-2">
<p>
We will explain the transformation by using another algorithm to
compute the factorial.
</p>

<pre class="example">
function fact (n:Int,acc:Int)
  if n = 0 then
    return acc
  else
    return fact(n-1,n * acc)

-- assuming that fact will be called with (acc = 1) from the outside:
function wrapper(n:Int)
  return fact(n,1);
</pre>

<p>
The algorithm works by keeping the product of from <code>n</code> to the desired
value in the parameter <code>acc</code>.
</p>

<div class="org-src-container">

<pre class="src src-C">#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

struct stack{ 
  int x;
  int y;
  int ret;
  struct stack* next;
};

typedef struct stack* stk;

stk s = NULL;



void push(int x,int y,int ret) {
  stk t = malloc(sizeof (struct stack));
  t-&gt;x = x;
  t-&gt;y = y;
  t-&gt;ret = ret;
  t-&gt;next = s;
  s = t;
}

void pop() {
  s = s-&gt;next;
}

int fact1 (int x,int y) {
  if (x == 1)
    return y;
  else
    return fact1(x-1,y*x);
}

// make order of eval. explicit

int fact2 (int x,int y) {
  if (x == 1)
    return y;
  else {
    y = y*x;
    x = x-1;
    return fact2(x,y);
  }
}

// put result in a global var
int result;

void fact3 (int x,int y) {
  if (x == 1)
    result = y;
  else {
    fact3(x-1,y*x);
  }
}

// put arguments on a stack
void fact4() {
  if (s-&gt;x == 1)
    result = s-&gt;y;
  else {
    push(s-&gt;x-1,s-&gt;y*s-&gt;x,0);
    fact4();
    pop();
  }
}

int label1 = 0;
int stop = 1;

// put the return address on the stack and do the jumps by hand
void fact5() {
  fact5:
  if (s-&gt;x == 1)
    result = s-&gt;y;
  else {
    push(s-&gt;x-1,s-&gt;y*s-&gt;x,label1);
    goto fact5;
  label1:
    pop();
  }

  if (s-&gt;ret == label1)
    goto label1;
}

// tail-call optim. (no need to save on the stack: we return before we
// can make any use of the saved stuff)

void fact6() {
  fact6:
  if (s-&gt;x == 1)
    result = s-&gt;y;
  else {
    s-&gt;y = s-&gt;y*s-&gt;x;
    s-&gt;x = s-&gt;x-1;
    goto fact6;
  label1:
    ;
  }

  if (s-&gt;ret == label1)
    goto label1;
}

// remove dead code
void fact7() {
  fact7:
  if (s-&gt;x == 1) 
    result = s-&gt;y;
  else {
    s-&gt;y = s-&gt;y*s-&gt;x;
    s-&gt;x = s-&gt;x-1; 
    goto fact7;
  }
}

//note now there is max 1 frame in the stack
// return the result as for a normal function.

int fact8(int x) {
  int y = 1;
  start:
  if (x == 1)
    result = y;
  else {
    y = y*x;
    x = x-1;
    goto start;
  }
  return y;
}

// recreate a loop
int fact9(int x) {
  int y = 1;
  while (x /= 1) {
    y = y*x;
    x = x-1;
  }
  return y;
}




int main(){
  printf("%d\n",fact1(5,1));
  printf("%d\n",fact2(5,1));
  fact3(5,1); printf("%d\n",result);
  push(5,1,stop); fact4(); pop(); printf("%d\n",result);
  push(5,1,stop); fact5(); pop(); printf("%d\n",result);
  push(5,1,stop); fact6(); pop(); printf("%d\n",result);
  push(5,1,stop); fact7(); pop(); printf("%d\n",result);
  printf("%d\n",fact8(5));
  printf("%d\n",fact9(5));
  return 0;
}
</pre>
</div>
</div>
</li>
<li><a id="sec-3-11-3-3" name="sec-3-11-3-3"></a>Conclusion<br  /><div class="outline-text-5" id="text-3-11-3-3">
<p>
Tail calls and loops are essentially equivalent: they are two
different manifestations of the same computing structure.
</p>
</div>
</li></ol>
</li>
<li><a id="sec-3-11-4" name="sec-3-11-4"></a>Other example: Tour de Hanoi<br  /><div class="outline-text-4" id="text-3-11-4">
<p>
<a href="Templates/Hanoi.c">Templates/Hanoi.c</a>
</p>
</div>
</li></ol>
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> ✪ Interlude: Garbage Collection</h2>
<div class="outline-text-2" id="text-4">
<p>
aka. Automatic memory management
The memory is freed automatically for you! (Magic!?)
</p>
<ul class="org-ul">
<li>Nah, chase pointers. (but what is a pointer)?
</li>
</ul>

<p>
Why GC discussed here?
</p>
<ul class="org-ul">
<li>Allows for much easier OOP (sharing)
</li>
<li>Practically impossible to do FP/Logic programming without it (sharing)
</li>
</ul>
</div>
<div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1"><span class="section-number-3">4.1</span> Question</h3>
<div class="outline-text-3" id="text-4-1">
<p>
Firefox uses a GC, but still, it is leaking memory. What is going on?
</p>
</div>
</div>
<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2"><span class="section-number-3">4.2</span> Question</h3>
<div class="outline-text-3" id="text-4-2">
<p>
Why are imperative languages usually not using GC?
</p>
</div>
</div>
</div>
<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> Object-oriented programming</h2>
<div class="outline-text-2" id="text-5">
</div><div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1"><span class="section-number-3">5.1</span> Coupling data and related code</h3>
<div class="outline-text-3" id="text-5-1">
</div><ol class="org-ol"><li><a id="sec-5-1-1" name="sec-5-1-1"></a>Example: Date<br  /><div class="outline-text-4" id="text-5-1-1">
<div class="org-src-container">

<pre class="src src-cpp">#include &lt;cstdio&gt;

class Date {
private:
  int year, month, day;
  // invariant: month &gt;= 1 &amp;&amp; month &lt;= 12 &amp;&amp; ... day ...

public:
  void check_invariant() {
    // (in reality this should be more clever)
    if (month &lt;= 12 &amp;&amp; month &gt;=1 &amp;&amp; day &gt;= 1) //; day &lt;= number_of_days_in(month);
      {
	// OK
      } else {
      // if we come here it means that the class breaks its own
      // invariant. That is: is is badly implemented.

      // throw badly_implemented_class;
    }
  }

  void shiftBy(int days) {
    day += days;
    // in reality this should be more clever
  }

  void show() {
    printf("%d-%d-%d\n",year,month,day);
  }

  Date(int y, int m, int d) {
    year  = y;
    month = m;
    day   = d;
    // check that we have a valid date here
  }

  Date() {
    day = 3;
    month = 2;
    year = 2013;
    // initialise to today's date by querying the OS
  }

};

int main () {
  Date appointment; // calls the default constructor
  appointment.shiftBy(7);
  appointment.show();
}
</pre>
</div>
</div>

<ol class="org-ol"><li><a id="sec-5-1-1-1" name="sec-5-1-1-1"></a>Translation: object ⟶ records + procedures<br  /><div class="outline-text-5" id="text-5-1-1-1">
<div class="org-src-container">

<pre class="src src-cpp">#include &lt;cstdlib&gt;
#include &lt;cstdio&gt;

struct Date {
  int year, month, day;

};

void check_invariant(Date* this_) {
  // (in reality this should be more clever)
  if (this_-&gt;month &lt;= 12 &amp;&amp; this_-&gt;month &gt;=1 &amp;&amp; this_-&gt;day &gt;= 1) //; day &lt;= number_of_days_in(month);
    {
      // OK
    } else {
    // if we come here it means that the class breaks its own
    // invariant. That is: is is badly implemented.

    // throw badly_implemented_class;

  }
}

void shiftBy(Date* this_, int days) {
  check_invariant(this_);
  this_-&gt;day += days;
  while (this_-&gt;day &gt; 31)
    {
      this_-&gt;day -= 31;
      this_-&gt;month ++;
    }
  // (in reality this should be more clever)
  check_invariant(this_);
}

void show(Date* this_) {
  printf("%d-%d-%d\n",this_-&gt;year,this_-&gt;month,this_-&gt;day);
  check_invariant(this_);
}

Date default_constructor() {
  Date this_;
  this_.year = 2014;
  this_.month = 1;
  this_.day = 29;
  // in reality: initialise to today's date by querying the OS
  check_invariant(&amp;this_);
  return this_;
}

int main () {
  Date appointment = default_constructor(); // calls the default constructor
  shiftBy(&amp;appointment,7);
  show(&amp;appointment);
}
</pre>
</div>
</div>
</li>

<li><a id="sec-5-1-1-2" name="sec-5-1-1-2"></a>Note: calling convention<br  /><div class="outline-text-5" id="text-5-1-1-2">
<p>
Objects are, almost always, passed by reference.
</p>

<p>
Methods often <i>update</i> the object they are applied to. If you want to be
able to call such methods, you better have a reference to it.
</p>

<p>
See also the Java calling convention (exercises).
</p>
</div>
</li></ol>
</li></ol>
</div>

<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2"><span class="section-number-3">5.2</span> Encapsulation</h3>
<div class="outline-text-3" id="text-5-2">
<p>
Mechanisms to make the fields private; such fields are then accessible
only via (public) method.
</p>
</div>

<ol class="org-ol"><li><a id="sec-5-2-1" name="sec-5-2-1"></a>Paradigm: Abstract Data Type (ADT)<br  /><div class="outline-text-4" id="text-5-2-1">
<ul class="org-ul">
<li>Example: "stack", "priority queue", &#x2026; from your data structures course
</li>
<li>Every data type comes with a specification (a class invariant)
</li>
<li>&#x2026; maybe in the form of <span class="underline">unit tests</span>
</li>
<li>Notion of data-invariant:
<ul class="org-ul">
<li>a condition which the representation must verify at all times
</li>
</ul>
<p>
(seen form outside the object)
</p>
</li>
<li>Advantage: it is easy to change representation of data
</li>

<li>Dogma: never any direct field access (cf. "set" and "get")
</li>

<li>Note: not every piece of data fits the ADT model.
Example: "Person" record.
</li>
</ul>
</div>
</li>

<li><a id="sec-5-2-2" name="sec-5-2-2"></a><span class="todo TODO">TODO</span> ✪ Exercise<br  /><div class="outline-text-4" id="text-5-2-2">
<p>
Write a unit test for a valid date, and call it at appropriate points
in the <code>Date</code> class
</p>
</div>
</li>
<li><a id="sec-5-2-3" name="sec-5-2-3"></a><span class="todo TODO">TODO</span> ✪ Exercise<br  /><div class="outline-text-4" id="text-5-2-3">
<p>
Change the representation of the Date class to a single integer which
counts the number of days since Jan 1st 2000.
</p>
</div>
</li></ol>
</div>
<div id="outline-container-sec-5-3" class="outline-3">
<h3 id="sec-5-3"><span class="section-number-3">5.3</span> Inheritance</h3>
<div class="outline-text-3" id="text-5-3">
</div><ol class="org-ol"><li><a id="sec-5-3-1" name="sec-5-3-1"></a>Example<br  /><div class="outline-text-4" id="text-5-3-1">
<p>
Simple example of inheritance:
</p>

<div class="org-src-container">

<pre class="src src-cpp">#include &lt;cstdio&gt;

class Animal {
public:
  virtual void sound() {
    printf("huh?\n");
  }
};

class Dog : public Animal {
public:
  virtual void sound() {
    printf("woof!!!\n");
  }
};

class Cat : public Animal {
private:
  int times;
public:
  virtual void sound() {
    // super.sound();
    times++;
    printf("meow %d\n", times);
  }
  Cat () {
    times = 0;
  }
};

// Make two derived classes; at least one should have a state.

// Test code:
void test(Animal* a) {
  a-&gt;sound();
}

void test2(Animal a) {
  a.sound();
}

main() {
  Cat a; //TODO: Test on the derived class
  test2(a);
  test2(a);
  // test2(a);
}
</pre>
</div>
</div>
</li>

<li><a id="sec-5-3-2" name="sec-5-3-2"></a>Transformation: embed method pointers<br  /><div class="outline-text-4" id="text-5-3-2">
<p>
The above example gets translated as follows:
</p>

<div class="org-src-container">

<pre class="src src-cpp">#include &lt;cstdio&gt;

struct Animal {
  void (*sound)(Animal*);
};

void animal_sound(Animal* this_) {
  printf("huh?\n");
}

// Pay attention: constructor needs to set the method pointers.
struct Animal construct_animal() {
  // TODO
  Animal a;
  a.sound = animal_sound;
  return a;
}

////////////////

struct Cat {
  void (*sound)(Cat *);
  int times;
};

void cat_sound(Cat* this_) {
  animal_sound(reinterpret_cast&lt;Animal*&gt;(this_));
  this_-&gt;times++;
  printf("meow %d\n", this_-&gt;times);
}

// Pay attention: constructor needs to set the method pointers.
struct Cat construct_cat() {
  // TODO
  Cat a;
  a.sound = cat_sound;
  a.times = 0;
  return a;
}

////////////////

struct Dog {
  void (*sound)(Dog *);
};

void dog_sound(Dog* this_) {
  printf("woof!!!\n");
}

// Pay attention: constructor needs to set the method pointers.
struct Dog construct_dog() {
  // TODO
  Dog a;
  a.sound = dog_sound;
  return a;
}

// In derived classes, added fields should come after.

// Translate test code.


// Test code:
void test(Animal* a) {
  a-&gt;sound(a);
}

void test2(Animal a) {
  animal_sound(&amp;a);
}

main() {
  Cat a = construct_cat(); //TODO: Test on the derived class
  // test(reinterpret_cast&lt;Animal*&gt;(&amp;a));
  test2(*reinterpret_cast&lt;Animal*&gt;(&amp;a));
}
</pre>
</div>
</div>

<ol class="org-ol"><li><a id="sec-5-3-2-1" name="sec-5-3-2-1"></a>Question: what happens on line (1)<br  /><div class="outline-text-5" id="text-5-3-2-1">
<ul class="org-ul">
<li><code>a-&gt;sound</code> is a function pointer;
</li>
<li>the function stored in that variable is called.
</li>
<li>if <code>a-&gt;sound</code> has been correctly set, either dog/cat case will be called.
</li>
<li>note the indirect call
</li>
</ul>
</div>
</li>

<li><a id="sec-5-3-2-2" name="sec-5-3-2-2"></a>Question: why are is cast (2) valid?<br  /><div class="outline-text-5" id="text-5-3-2-2">
<p>
The layout of the parent class is exactly the same as that of the subclass.
</p>
</div>
</li>
<li><a id="sec-5-3-2-3" name="sec-5-3-2-3"></a>Question: what if the Dog class had an extra method/field?<br  /><div class="outline-text-5" id="text-5-3-2-3">
<p>
(In general, there can be more fields/methods in the subclass, found
<span class="underline">after</span> the fields of the top class)
</p>
</div>
</li>
<li><a id="sec-5-3-2-4" name="sec-5-3-2-4"></a>Question: could you copy objects instead of passing by reference?<br  /><div class="outline-text-5" id="text-5-3-2-4">
<p>
No! If one passes a copy, the inherited methods/fields are not
accessible when doing an "upcast". This means that, when one calls a
method which is overriden, it could try to access fields that are not
present.
</p>

<p>
In C++: the method pointer is accessed only if the object is a
reference.
</p>
</div>
</li></ol>
</li>

<li><a id="sec-5-3-3" name="sec-5-3-3"></a>Liskov substitution principle and Polymorphism<br  /><div class="outline-text-4" id="text-5-3-3">
<p>
if class <code>B</code> inherits class <code>A</code>, then, for any x,
</p>

<pre class="example">
x : B  ⇒  x : A
</pre>

<p>
This means that
</p>

<ol class="org-ol">
<li><code>x</code> has multiple types
</li>

<li>That is: whenever a function <code>f</code> has an parameter of type <code>A</code>, one
can pass an argument of type <code>B</code>.  By deriving from <code>A</code>, a lot of
code is automatically ready to work with <code>B</code>.  (Conversely, if you
write code working for <code>A</code>, it will be useful in many contexts)
</li>
</ol>

<p>
This is one instance of an important phenomenon: <i>polymorphism</i>. The
kind of polymorphism linked with inheritance is <i>inclusion
polymorphism</i>. Recall the definition of set-inclusion:
</p>


<pre class="example">
B ⊆ A     iff     x ∈ B  ⇒  x ∈ A
</pre>

<p>
One says that <code>B</code> is a subtype of <code>A</code>.
</p>

<p>
Liskov proposes the principle:
</p>

<p>
if <code>A</code> is a subtype of <code>B</code> and prove a property about any object of
<code>A</code>, then it should be true of any object of type <code>B</code>.
</p>

<p>
This is somewhat stronger than the definition of having multiple types
given above.
</p>

<p>
Read (✪) more about <a href="http://en.wikipedia.org/wiki/Polymorphism_(computer_science)">polymorphism</a> and the <a href="http://en.wikipedia.org/wiki/Liskov_substitution_principle">substitution principle</a> on
Wikipedia.
</p>
</div>
</li>
<li><a id="sec-5-3-4" name="sec-5-3-4"></a>What happens when functions have arguments?<br  /><div class="outline-text-4" id="text-5-3-4">
<p>
In many languages, the type of the arguments of derived functions must
be the SAME as that of the overridden function.
</p>
</div>
<ol class="org-ol"><li><a id="sec-5-3-4-1" name="sec-5-3-4-1"></a>Co/Contra-variance (⋆⋆⋆)<br  /><div class="outline-text-5" id="text-5-3-4-1">
<p>
A perhaps natural expectation is that you could make the arguments
change as the type of the object. Ex.:
</p>


<pre class="example">
class Additive 
  method Add(Additive)

class Integer extends Additive
  method Add(Integer)
</pre>

<p>
&#x2026; but in fact this violates the substitution principle!
</p>

<p>
See also the <a href="http://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)">wikipedia article</a>.
</p>
</div>
</li>
<li><a id="sec-5-3-4-2" name="sec-5-3-4-2"></a>Exercise<br  /><div class="outline-text-5" id="text-5-3-4-2">
<p>
Use the above two classes in a way that shows violation of
substitution.
</p>
</div>
</li></ol>
</li>

<li><a id="sec-5-3-5" name="sec-5-3-5"></a>Extension (✪): method tables<br  /><div class="outline-text-4" id="text-5-3-5">
<p>
Is the <code>sound</code> function pointer ever modified? No!
</p>

<ul class="org-ul">
<li>How can we save space if there are many methods per class? 
</li>
</ul>

<p>
⟶ Use one more indirection!
</p>

<ul class="org-ul">
<li>group the method pointers in a single table per class. Each object
then points to this table.
</li>
</ul>
</div>
<ol class="org-ol"><li><a id="sec-5-3-5-1" name="sec-5-3-5-1"></a>Example<br  /><div class="outline-text-5" id="text-5-3-5-1">
<pre class="example">
record AnimalMethods
  Pet : function
  Vocalise : function

record DogMethods
  Pet : function
  Vocalise : function
  
dogMethods = {Pet := petDog, ...}
</pre>
</div>
</li></ol>
</li>

<li><a id="sec-5-3-6" name="sec-5-3-6"></a>Paradigm: inheritance everywhere<br  /><div class="outline-text-4" id="text-5-3-6">
<ul class="org-ul">
<li>Multiple "cases" can be implemented by inheriting a common class
</li>
<li>Dogma: no "if".
</li>
<li>Specific behavior is implemented in derived methods
</li>

<li>Open question: multiple dispatch!
</li>
</ul>
</div>
</li>

<li><a id="sec-5-3-7" name="sec-5-3-7"></a>✪ Reading/Exercise: Javascript prototypes<br  /><div class="outline-text-4" id="text-5-3-7">
<p>
<a href="http://en.wikipedia.org/wiki/ECMAScript_syntax#Objects">http://en.wikipedia.org/wiki/ECMAScript_syntax#Objects</a>
</p>
</div>
</li></ol>
</div>

<div id="outline-container-sec-5-4" class="outline-3">
<h3 id="sec-5-4"><span class="section-number-3">5.4</span> Multiple-inheritance &amp; interfaces</h3>
<div class="outline-text-3" id="text-5-4">
</div><ol class="org-ol"><li><a id="sec-5-4-1" name="sec-5-4-1"></a>Motivation<br  /><div class="outline-text-4" id="text-5-4-1">
<p>
Save work:
</p>
<ol class="org-ol">
<li>Better reuse of code (possibly the derived class can use code from
both its parents)
</li>
<li>More polymorphism!
</li>
</ol>

<p>
Examples:
</p>
<pre class="example">
class Computer
class Phone
class SmartPhone inherits Computer, Phone
</pre>

<pre class="example">
class Teacher
class Student
class GradStud inherits Teacher, Student
</pre>
</div>
</li>

<li><a id="sec-5-4-2" name="sec-5-4-2"></a>Diamond problem<br  /><ol class="org-ol"><li><a id="sec-5-4-2-1" name="sec-5-4-2-1"></a>On a conceptual level:<br  /><div class="outline-text-5" id="text-5-4-2-1">

<div class="figure">
<p><img src="diamond.svg" alt="diamond.svg" />
</p>
</div>

<p>
Does a grad student have two names? &#x2026; no
Does a grad student have two bosses? &#x2026; yes (one as a teacher and one as a student).
BUT some other fields might need to be duplicated, if they have a
</p>

<p>
⟶ Big headache
</p>
</div>
</li>

<li><a id="sec-5-4-2-2" name="sec-5-4-2-2"></a>On an implementation level:<br  /><div class="outline-text-5" id="text-5-4-2-2">
<pre class="example">
class Person
  Name
  BirthDate


class Student inherits Person
  CourseGrade
  ...

class Teacher inherits Person
  numberOfStudents 
  ...

class GradStud inherits Student, Teacher
</pre>

<p>
What is the record corresponding to GradStud?
If we copy all the fields, we get:
</p>

<pre class="example">
Name
BirthDate
CourseGrade
Name
BirthDate
numberOfStudents
</pre>

<p>
The record can be casted to Student (as normal, the 3 last fields will
never be accessed by methods in the Student class) or Teacher (by
adding 3 to the pointer).
</p>

<p>
Aside: what if a method in the class Student updates the Name? Then
there is a problem: the gradstudent will end up with 2 different
Names!
</p>

<p>
Let's say we want to have a single copy of Name and BirthDate:
</p>
<pre class="example">
Name
BirthDate
CourseGrade
numberOfStudents
</pre>

<p>
Problem: what happens if you see the GradStud as a Teacher?  The
translation to "pure" imperative programming becomes much more
complicated.
</p>
</div>
</li></ol>
</li>

<li><a id="sec-5-4-3" name="sec-5-4-3"></a>Interfaces<br  /><div class="outline-text-4" id="text-5-4-3">
<p>
As it is often the case, the issue is due to side effects
(hidden modification of state). It appears only if the shared class
has mutable fields. An important case of immutable fields are methods
(their code is fixed once an for the lifetime of the object, in fact
it is the same for all objects in a class). Hence the notion of
<i>Interface</i>: a class without fields. In Java, there is special support
for interfaces, and one can inherit many of them.
</p>

<p>
In sum, interfaces are for multiple subtyping but not multiple
inheritance: polymorphism is well-supported, but not code-reuse.
</p>
</div>

<ol class="org-ol"><li><a id="sec-5-4-3-1" name="sec-5-4-3-1"></a>✪ Exercise (⋆⋆)<br  /><div class="outline-text-5" id="text-5-4-3-1">
<p>
Adapt the translation from objects to records to support interfaces
</p>
</div>
</li>

<li><a id="sec-5-4-3-2" name="sec-5-4-3-2"></a>✪ Exercise (⋆⋆)<br  /><div class="outline-text-5" id="text-5-4-3-2">
<p>
Adapt the translation of interfaces to use method tables.
</p>
</div>
</li></ol>
</li></ol>
</div>

<div id="outline-container-sec-5-5" class="outline-3">
<h3 id="sec-5-5"><span class="section-number-3">5.5</span> Forward reference: ``objects are poor man's <a href="#closures">6.5.2</a>''</h3>
<div class="outline-text-3" id="text-5-5">
<p>
Note the similarity between objects and closures: they are both
encoded as state/environment + function. pointer.
</p>

<p>
In particular, in the <a href="http://en.wikipedia.org/wiki/Observer_pattern">Observer pattern</a>, the Observer interface can be
advantageously replaced by a function, making registerObserver a
higher-order function.
</p>
</div>
</div>
<div id="outline-container-sec-5-6" class="outline-3">
<h3 id="sec-5-6"><span class="section-number-3">5.6</span> <span class="todo TODO">TODO</span> Traits; Objects as fix-points (✪)</h3>
</div>
</div>
<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> Functional programming</h2>
<div class="outline-text-2" id="text-6">
</div><div id="outline-container-sec-6-1" class="outline-3">
<h3 id="sec-6-1"><span class="section-number-3">6.1</span> A bit of syntax</h3>
<div class="outline-text-3" id="text-6-1">
</div><ol class="org-ol"><li><a id="sec-6-1-1" name="sec-6-1-1"></a>Function definitions<br  /><div class="outline-text-4" id="text-6-1-1">
<p>
Similar to mathematical notation:
</p>

<pre class="example">
minimum (x,y) = if x &lt; y
                  then x
                  else y
</pre>
</div>
</li>

<li><a id="sec-6-1-2" name="sec-6-1-2"></a>(λ) abstractions / local functions<br  /><div class="outline-text-4" id="text-6-1-2">
<p>
In the literature:
</p>

<pre class="example">
minimum = λ(x,y). if x &lt; y
                      then x
                      else y
</pre>

<p>
In Haskell:
</p>

<pre class="example">
minimum = \(x,y) -&gt; if x &lt; y
                      then x
                      else y
</pre>
</div>
</li>

<li><a id="sec-6-1-3" name="sec-6-1-3"></a>Application is LEFT associative.<br  /><div class="outline-text-4" id="text-6-1-3">
<ul class="org-ul">
<li>No need for parentheses:
<pre class="example">
f x   ==  f(x)
</pre>
</li>
<li>Left leaning:
<pre class="example">
f x y == (f x) y  ==  (f(x))(y)
</pre>
</li>
</ul>
</div>
</li>

<li><a id="sec-6-1-4" name="sec-6-1-4"></a>Function arrow is RIGHT associative<br  /><div class="outline-text-4" id="text-6-1-4">
<pre class="example">
a -&gt; b -&gt; c     ==       a -&gt; (b -&gt; c)
</pre>
</div>
</li>

<li><a id="sec-6-1-5" name="sec-6-1-5"></a>Reading (as much as necessary to understand Haskell syntax)<br  /><div class="outline-text-4" id="text-6-1-5">
<ul class="org-ul">
<li><a href="http://www.haskell.org/tutorial">The "gentle" introduction to Haskell</a>
</li>
<li><a href="http://learnyouahaskell.com/">Learn you a Haskell, for great good!</a>
</li>
</ul>
</div>
</li></ol>
</div>
<div id="outline-container-sec-6-2" class="outline-3">
<h3 id="sec-6-2"><span class="section-number-3">6.2</span> Algebraic Types</h3>
<div class="outline-text-3" id="text-6-2">
<p>
In this subsection we will refine our understanding of the type
structure, which we have used implicitly so far.
</p>

<p>
Summed up here:
<a href="Final/AlgebraicTypes.hs">Final/AlgebraicTypes.hs</a>
</p>
</div>

<ol class="org-ol"><li><a id="sec-6-2-1" name="sec-6-2-1"></a>Parametric types<br  /><div class="outline-text-4" id="text-6-2-1">
<p>
Parameterize a type by another type means to have abstraction over
types.
</p>

<p>
Most functional languages have abstraction over types, but some
(many?) OO languages as well.
</p>

<p>
Example in Java:
</p>

<pre class="example">
Interface List&lt;E&gt; extends Collection&lt;E&gt;
</pre>

<p>
In this case <code>E</code> is the the type of elements in the list.
</p>

<p>
In C++ one can use templates to abstract over types, but the semantics
is a bit strange, so we won't discuss it further.
</p>


<p>
In haskell one can write:
</p>

<pre class="example">
type T a = ... some type referring to a ...
</pre>

<p>
or
</p>

<pre class="example">
data T a = ... constructors referring to a ...
</pre>
</div>
</li>

<li><a id="sec-6-2-2" name="sec-6-2-2"></a>Sum types<br  /><div class="outline-text-4" id="text-6-2-2">
<p>
From a value of type <code>A + B</code>, one can extract <i>either</i> an <code>A</code> <i>or</i> a
<code>B</code>. Conversely, it suffices of either an <code>A</code> or a <code>B</code> to construct a
value of type <code>A + B</code>.
</p>

<ul class="org-ul">
<li>In Java, this can be implemented by having two clases <code>A</code> and <code>B</code>
</li>
</ul>
<p>
extending a common super-class (or implementing a common interface).
</p>

<ul class="org-ul">
<li>In C, this can be implemented by a <i>tagged</i> union. (Unions in C do not
</li>
</ul>
<p>
give information about which of <code>A</code> or <code>B</code> is available, so an extra
bit of information (the tag) must be used for that purporse)
</p>

<ul class="org-ul">
<li>In Haskell, a sum type can be implemented like this:
</li>
</ul>

<pre class="example">
data a + b = Inl a | Inr b
</pre>

<p>
note that each case uses a tag (<code>ATag</code> or <code>BTag</code> in this case). The
tags is used in pattern matching:
</p>

<pre class="example">
test :: String + Int -&gt; String
test (Inl x) = "I got an A: " ++ show x
test (Inr y) = "I got a  B: " ++ show y
</pre>

<p>
The tags can be used to construct values, indeed, they are also (and
most commonly) called constructors.
</p>

<pre class="example">
Inl :: a -&gt; a + b
Inr :: b -&gt; a + b
</pre>
</div>
</li>

<li><a id="sec-6-2-3" name="sec-6-2-3"></a>Product types<br  /><div class="outline-text-4" id="text-6-2-3">
<p>
From a value of <code>A × B</code>, one can extract <i>both</i> an <code>A</code> <i>and</i> a
<code>B</code>. Conversely, from both an <code>A</code> and a <code>B</code> one can construct a value
of type <code>A × B</code>.
</p>

<ul class="org-ul">
<li>In Java, C, etc. this can be implemented by constructing a class or
record which has both a field of type <code>A</code> and one of type <code>B</code>.
</li>

<li>In Haskell, a product type can be implemented like this:
</li>
</ul>

<pre class="example">
data a * b = Pair A B
</pre>

<p>
when pattern matching on the <code>Pair</code> tag one gets both an <code>A</code> and a <code>B</code>.
</p>

<pre class="example">
test :: String * Int -&gt; String
test (Pair x y) = "I got an A: " ++ show x ++ " and a B:" ++ show y
</pre>

<p>
There is also special syntax for product types. (Note: the syntax is
the same for types and values)
</p>

<pre class="example">
test : (String,Int) -&gt; String
test (x,y) = "I got an A: " ++ show x ++ " and a B:" ++ show y
</pre>

<p>
Product types are also called tuples.
</p>
</div>
</li>

<li><a id="sec-6-2-4" name="sec-6-2-4"></a>A bit of algebra<br  /><div class="outline-text-4" id="text-6-2-4">
<p>
An isomorphism <code>A ≅ B</code> is a pair of functions <code>f : A -&gt; B</code> and <code>g : B -&gt; A</code>,
with <code>f ∘ g = id = g ∘ f</code>.
</p>

<p>
For every a algebraic law, there is an isomorphism. Consider:
</p>

<pre class="example">
(A + B)×C ≅ A×C + B×C
</pre>

<pre class="example">
f :: (a+b)*c -&gt; (a*c) + (b*c)
f (Pair (Inl x) z) = Inl (Pair x z)
f (Pair (Inr x) z) = Inr (Pair x z)
</pre>

<pre class="example">
g :: (a*c) + (b*c) -&gt; (a+b)*c
g (Inl (Pair x z)) = (Pair (Inl x) z)
g (Inr (Pair x z)) = (Pair (Inr x) z)
</pre>

<p>
This is why the types are called algebraic!
</p>

<p>
Some more laws, which all translate to isomorphisms:
</p>

<pre class="example">
A×B ≅ B×A
(A + 0) ≅ A
(A × 1) ≅ A
(A × 0) ≅ 0
</pre>

<ul class="org-ul">
<li>The unit type <code>1</code> is a tuple with no element; in Haskell written <code>()</code>.
</li>
<li>The empty type <code>0</code> is a , which can be defined in Haskell by
</li>
</ul>

<pre class="example">
data Zero
</pre>

<p>
with no constructors.
</p>
</div>
</li>

<li><a id="sec-6-2-5" name="sec-6-2-5"></a>Example<br  /><div class="outline-text-4" id="text-6-2-5">
<p>
A boolean can be either of two given specific values. Hence:
</p>

<pre class="example">
Bool ≅ 1 + 1
</pre>

<p>
In Haskell the <code>Bool</code> type is predefined, with meaningful tag names.
</p>

<pre class="example">
data Bool = True | False
</pre>
</div>
</li>
<li><a id="sec-6-2-6" name="sec-6-2-6"></a>Counting<br  /><div class="outline-text-4" id="text-6-2-6">
<p>
Reading the type expression as a natural number gives you the number
of distinct values that the type has:
</p>

<pre class="example">
Bool × Bool = (1 + 1) × (1 + 1)
Bool + Bool = (1 + 1) + (1 + 1)
</pre>
</div>
</li>

<li><a id="sec-6-2-7" name="sec-6-2-7"></a>Recursive types<br  /><div class="outline-text-4" id="text-6-2-7">
<p>
Lists can be defined as follows, using <span class="underline">recursion</span>:
</p>

<pre class="example">
List a = 1 + (a × List a)
</pre>

<p>
Haskell syntax:
</p>

<pre class="example">
data List a = Nil | Cons a (List a)
</pre>

<p>
Trees with any number of children:
</p>

<pre class="example">
RoseTree a = RT a (List (RoseTree a))
</pre>

<p>
In fact there is a special syntax for lists in Haskell:
</p>

<pre class="example">
data [a] = [] | a : [a]
</pre>

<p>
(Note that the brackets have a different meaning if used in a type
expression or in a value expression)
</p>

<p>
Examples:
</p>

<ul class="org-ul">
<li>'a':'b':'c':[] has type [Char]
</li>
<li>[1,2,4] has type [Int]
</li>
</ul>
</div>
</li>

<li><a id="sec-6-2-8" name="sec-6-2-8"></a>Example<br  /><div class="outline-text-4" id="text-6-2-8">
<div class="org-src-container">

<pre class="src src-haskell">import Prelude hiding (sum, product)

-- data List a = Nil a | Cons a (List a) | ...

exercise = error "todo"

sum :: [Int] -&gt; Int
sum xs = exercise

product xs = exercise

append :: ([Int],[Int]) -&gt; [Int]
append (xs,ys) = exercise
</pre>
</div>
</div>
</li>

<li><a id="sec-6-2-9" name="sec-6-2-9"></a>Function types<br  /><div class="outline-text-4" id="text-6-2-9">
<p>
<code>A → B</code> corresponds to <code>B^A</code>
</p>

<p>
Indeed:
</p>

<pre class="example">
Bool → A     ≅  A × A
(A+B) → C    ≅  (A → C) × (B → C)
(A × B) → C  ≅  A → (B → C)
</pre>
</div>

<ol class="org-ol"><li><a id="sec-6-2-9-1" name="sec-6-2-9-1"></a>Transformation: Currification<br  /><div class="outline-text-5" id="text-6-2-9-1">
<p>
The last of these isomorphisms is (implicitly) used all the time in
Haskell programming.
</p>

<pre class="example">
currify : ((A × B) → C)  →   (A → (B → C))
currify = \f -&gt; \a -&gt; \b -&gt; f (a,b)

uncurrify :: (A → (B → C)) → ((A × B) → C)
uncurrify = \g -&gt; \(a,b) -&gt; (f a) b
</pre>

<p>
Indeed, one almost always write <code>A → B → C</code> (which is equal to <code>A → (B
→ C)</code> by associativity rules) for a function which takes two
arguments, one of type <code>A</code> and one of type <code>B</code>.
</p>
</div>
</li></ol>
</li>

<li><a id="sec-6-2-10" name="sec-6-2-10"></a>Transformation: Algebraic data type ⟶ inheritance<br  /><div class="outline-text-4" id="text-6-2-10">
<ul class="org-ul">
<li>×: supported by records
</li>
<li>+: one can use inheritance to implement sum types, as in the
following example.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-java">class Product&lt;A,B&gt; {
    A a;
    B b;
};

interface List&lt;A&gt; {
    public void print();
    public List&lt;A&gt; append(List&lt;A&gt; xs);
    public List&lt;A&gt; reverse();
};

class Nil&lt;A&gt; implements List&lt;A&gt; {
    public void print() {
	System.out.println("empty.");
    }
    public List&lt;A&gt; append(List&lt;A&gt; xs) {
	return xs;
    }
    public List&lt;A&gt; reverse() {
	return this;
    };
}

class Cons&lt;A&gt; implements List&lt;A&gt; {
    A head;
    List&lt;A&gt; tail;
    public Cons (A h, List&lt;A&gt; t) {
	head = h;
	tail = t;
    }
    public List&lt;A&gt; append(List&lt;A&gt; ys) {
	return new Cons&lt;A&gt;(this.head,tail.append(ys));
    }
    public List&lt;A&gt; reverse() {
	return tail.reverse().append(new Cons&lt;A&gt;(head, new Nil&lt;A&gt;()));
    }
    public void print() {
	System.out.println("Element: " + head.toString());
	tail.print();
    }
}

public class AlgebraicTypes {
    public static void main(String args[]) {
	List&lt;String&gt; l = new Cons&lt;String&gt;("one", new Cons&lt;String&gt;("two", new Nil&lt;String&gt;()));
	l.reverse().print();
	// l.print();
    }
}
</pre>
</div>
</div>
</li>

<li><a id="sec-6-2-11" name="sec-6-2-11"></a>Remark: the expression problem<br  /><div class="outline-text-4" id="text-6-2-11">
<ul class="org-ul">
<li>In an OO language such as Java, it is convenient to add new cases to
sum types, but it is cumbersome to add a new algorithm. (In the
above example, <code>sum</code> is scattered among 3 classes/interfaces)
</li>
<li>In a language such as Haskell, it is convenient to add a new
algorithm (the fold function is localized at a single place), but
cumbersome to add a case in a sum type (why?).
</li>
</ul>
</div>
</li></ol>
</div>

<div id="outline-container-sec-6-3" class="outline-3">
<h3 id="sec-6-3"><span class="section-number-3">6.3</span> Abstracting over functions</h3>
<div class="outline-text-3" id="text-6-3">
<p>
<a href="Final/Fold.hs">Final/Fold.hs</a>
</p>
</div>
<ol class="org-ol"><li><a id="sec-6-3-1" name="sec-6-3-1"></a>Example: fold (sometimes called reduce)<br  /><div class="outline-text-4" id="text-6-3-1">
<p>
Consider the following function, to sum the elements in a list:
</p>
<div class="org-src-container">

<pre class="src src-haskell">sum Nil          = 0
sum (Cons x xs)  = x + sum xs
</pre>
</div>

<p>
Consider now the following function, which multiplies the elements in
a list:
</p>
<div class="org-src-container">

<pre class="src src-haskell">product Nil         = 1
product (Cons x xs) = x * product xs
</pre>
</div>

<p>
<b>Same pattern ⟶ Abstract out the difference ! (Parametrize)</b>
</p>

<div class="org-src-container">

<pre class="src src-haskell">foldr :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b
foldr (?) k [] = k
foldr (?) k (x:xs) = x ? foldr (?) k xs
</pre>
</div>
<p>
such that
</p>

<pre class="example">
sum     xs = foldr (\x y -&gt; x + y) 0 xs
</pre>
<p>
and
</p>
<pre class="example">
product xs = foldr (\x y -&gt; x * y) 1 xs
</pre>


<ul class="org-ul">
<li>Notes
<ul class="org-ul">
<li>I give some help by writing the type of the foldr function; but 
you can ignore it for now.
</li>
<li><code>foldr</code> is a function taking another function in parameter: a
higher-order function.
</li>
</ul>
</li>
</ul>
</div>
</li>

<li><a id="sec-6-3-2" name="sec-6-3-2"></a>Example: map<br  /><div class="outline-text-4" id="text-6-3-2">
<p>
Consider these two examples:
</p>
<pre class="example">
multiplyBy n Nil = Nil
multiplyBy n (Cons x xs) = Cons (n*x) (multiplyBy n xs)
</pre>

<pre class="example">
squareAll Nil = Nil
squareAll (Cons x xs) = Cons (x^2) (squareAll xs)
</pre>


<p>
Capture the pattern in the following 
</p>
<pre class="example">
map :: (a -&gt; b) -&gt; List a -&gt; List b
map f xs = ?
</pre>
</div>
</li>

<li><a id="sec-6-3-3" name="sec-6-3-3"></a>Polymorphism comes back (⋆⋆⋆)<br  /><div class="outline-text-4" id="text-6-3-3">
<p>
Note that, both in <code>foldr</code> and <code>map</code>, by abstracting over the functions to
apply on the elements on the list, the resulting code is also
abstracted from the <i>type</i> of the elements in the list. That is, (eg.)
map works on lists of <i>anything</i>, as long as the type of function that
we pass to map (1st argument) matches. This is captured formally in
the type of map.
</p>

<p>
Effectively, map has mutliple types. Because the type is parametrized
over any types <code>a</code> and <code>b</code>, this is called <i>parametric polymorphism</i>.
</p>
</div>
</li>

<li><a id="sec-6-3-4" name="sec-6-3-4"></a>Reading:<br  /><div class="outline-text-4" id="text-6-3-4">
<p>
"Can Programming Be Liberated From the von Neumann Style?", John
Backus, 1977 Turing Award Lecture
<a href="http://www.thocp.net/biographies/papers/backus_turingaward_lecture.pdf">http://www.thocp.net/biographies/papers/backus_turingaward_lecture.pdf</a>
(recommended to read up to p. 620).
</p>
</div>
</li></ol>
</div>

<div id="outline-container-sec-6-4" class="outline-3">
<h3 id="sec-6-4"><span class="section-number-3">6.4</span> Paradigm: HOT!</h3>
<div class="outline-text-3" id="text-6-4">
<p>
Higher-Order and Typed
</p>
<ul class="org-ul">
<li>Any part of a function can be abstracted over (before one could not
abstract over functions)
<ul class="org-ul">
<li>Possibility to make the code more clear
</li>
<li>Good for reuse!
</li>
</ul>
</li>
<li>Types capture a coarse-grained meaning of each function
<ul class="org-ul">
<li>One does not get lost in keeping track of details (so easily)
</li>
<li>Can use function types to represent objects that were before complex data structures.
<ul class="org-ul">
<li>example: A set can be represented by its characteristic function
</li>
<li>There are trade-offs (performance!)
</li>
</ul>
</li>
</ul>
</li>
<li>Further reading (⋆) 
<ul class="org-ul">
<li>Haskell vs. Ada vs. C++ vs. Awk vs. &#x2026; ─ An Experiment in Software Prototyping Productivity
</li>
<li>especially, sec. 6.1, 7, 8
</li>
<li><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.117.1208&rep=rep1&type=pdf">http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.117.1208&rep=rep1&type=pdf</a>
</li>
</ul>
</li>
</ul>

<p>
<a href="Final/HOT.hs">Final/HOT.hs</a>
</p>
</div>
</div>

<div id="outline-container-sec-6-5" class="outline-3">
<h3 id="sec-6-5"><span class="section-number-3">6.5</span> Meaning of Higher-Order functions</h3>
<div class="outline-text-3" id="text-6-5">
<p>
Remark that 1st order Haskell programs are easy to translate to C.
</p>

<p>
That is, a function <i>returning</i> a function (say of type <code>f : Int -&gt; Int
-&gt; Int</code>) can be transformed into a simple function of two
arguments using the (de)currification isomorphism seem above.
</p>
</div>
<ol class="org-ol"><li><a id="sec-6-5-1" name="sec-6-5-1"></a>Transformation: Inlining higher-order functions<br  /><div class="outline-text-4" id="text-6-5-1">
<p>
We can use the substitution model to see the meaning of higher-order abstraction.
</p>

<div class="org-src-container">

<pre class="src src-haskell">map :: (a -&gt; b) -&gt; List a -&gt; List b
map f xs = case xs of 
   [] -&gt;  []
   (x:xs) -&gt; f x : map f xs

multiply n xs = map (\x -&gt; x * n) xs
</pre>
</div>

<p>
Substitute the formal parameter <code>f</code> by its argument <code>(\x -&gt; x * n)</code> in
the code of <code>map</code>.
</p>

<div class="org-src-container">

<pre class="src src-haskell">multiply n xs = case xs of
    [] -&gt;  []
    (x:xs) -&gt; (\x -&gt; x * n) x : map (\x -&gt; x * n) xs
</pre>
</div>

<p>
But we know that <code>multiply n xs == map (\x -&gt; x * n) xs</code>
</p>

<div class="org-src-container">

<pre class="src src-haskell">multiply n xs = case xs of
    [] -&gt;  []
    (x:xs) -&gt; (\x -&gt; x * n) x : multiply n xs
</pre>
</div>

<p>
Reduce again:
</p>

<div class="org-src-container">

<pre class="src src-haskell">multiply n xs = case xs of
    [] -&gt;  []
    (x:xs) -&gt; x * n : multiply f xs
</pre>
</div>

<p>
Inlining/the substition model can be used in real programs to get rid
of higher-order functions. There are however to problems with this:
</p>

<ol class="org-ol">
<li>explosion of the code size
</li>
<li>maybe impossible!
<ul class="org-ul">
<li>in presence of recursion (infinite programs)
</li>
<li>or if the code of the function arguments is
</li>
</ul>
<p>
not available.  That is, if we want to make a library of
higher-order functions.
</p>
</li>
</ol>
</div>
</li>

<li><a id="sec-6-5-2" name="sec-6-5-2"></a>Transformation: Defunctionalisation (explicit <a id="closures" name="closures"></a>)<br  /><ol class="org-ol"><li><a id="sec-6-5-2-1" name="sec-6-5-2-1"></a>Example<br  /><div class="outline-text-5" id="text-6-5-2-1">
<ul class="org-ul">
<li>Source
</li>
</ul>
<div class="org-src-container">

<pre class="src src-haskell">map :: (a -&gt; b) -&gt; List a -&gt; List b
map f [] = []
map f (x:xs) = f x : map f xs

call0 = map (\x -&gt; x + 4)
call1 n = map (\x -&gt; x * n)
</pre>
</div>

<ul class="org-ul">
<li>Target
</li>
</ul>
<div class="org-src-container">

<pre class="src src-haskell">map :: Closure -&gt; List a -&gt; List b
map f [] = []
map f (x:xs) = apply f x : map f xs

call0 xs = map Add4 xs
call1 n = map (MultiplyBy n)

apply (MultiplyBy n) x = x * n
apply (Add4)         x = x + 4

<span id="coderef-closure definition" class="coderef-off">data Closure = MultiplyBy Int | Add4 | ...      -- (closure definition)</span>
</pre>
</div>

<p>
The trick is to replace each function parameter by a data-type. The
constructors of the data type are made to represent the possible
arguments. The closure stores all the variables of the environment
used in the argument.
</p>

<p>
Note that there may be more kind of closures, so there may be more
cases in <a href="#coderef-ref:closure definition"class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-ref:closure definition');" onmouseout="CodeHighlightOff(this, 'coderef-ref:closure definition');">nil</a>.
</p>
</div>
</li>

<li><a id="sec-6-5-2-2" name="sec-6-5-2-2"></a>Definition: Closure<br  /><div class="outline-text-5" id="text-6-5-2-2">
<p>
A closure is the <b>representation</b> of a lambda-abstraction; ie. a piece
of code together with the environment where it is to be executed.
</p>

<p>
Some authors sometimes use closure when they mean a
lambda-abstraction. Do not be confused: remember the above definition.
</p>

<p>
(The definition of <a href="http://en.wikipedia.org/wiki/Closure">closures on wikipedia</a> agrees with me.)
</p>
</div>
</li>

<li><a id="sec-6-5-2-3" name="sec-6-5-2-3"></a>Exercise: Implement the above example C.<br  /><div class="outline-text-5" id="text-6-5-2-3">
<p>
Hint: Instead of a 'tag', use a function pointer.
</p>

<p>
Solution:
<a href="Final/ExplicitClosure.cpp">Final/ExplicitClosure.cpp</a>
</p>

<p>
Note the similarity with the implementation of <i>objects</i>!
</p>
</div>
</li>
<li><a id="sec-6-5-2-4" name="sec-6-5-2-4"></a>Exercise: Implement the above example Java<br  /><div class="outline-text-5" id="text-6-5-2-4">
<p>
Hints
</p>
<ul class="org-ul">
<li>Instead of a tag, make a derived class ('apply' is a method)
</li>
<li>Or just apply the Algebraic Data Type ==&gt; Classes transformation seen above.
</li>
</ul>

<p>
<a href="Final/ExplicitClosures.java">Final/ExplicitClosures.java</a>
</p>

<p>
See the similarity with Observer/EventListener pattern in Java:
</p>

<div class="org-src-container">

<pre class="src src-pseudo-Java">interface Listener -- "Closure"
  void respond(); -- "apply"

class MyPrintAction implements Listener -- "Function representation"
   String text -- "environment"
   respond() {
     print(text);
   }

button.onPress(new MyPrintAction("Hello there"));
</pre>
</div>

<p>
Corresponding haskell code: 
  onPress button $ print "Hello there"
</p>

<p>
Hence the proverb: "Objects are Poor Man's closures."
</p>
</div>
</li>

<li><a id="sec-6-5-2-5" name="sec-6-5-2-5"></a>Other Example<br  /><div class="outline-text-5" id="text-6-5-2-5">
<p>
<a href="Templates/ExplicitClosure.hs">Templates/ExplicitClosure.hs</a>
<a href="Final/ExplicitClosure.hs">Final/ExplicitClosure.hs</a>
</p>
</div>
</li></ol>
</li></ol>
</div>
<div id="outline-container-sec-6-6" class="outline-3">
<h3 id="sec-6-6"><span class="section-number-3">6.6</span> Purity and its Consequences</h3>
<div class="outline-text-3" id="text-6-6">
<p>
Did you know that side effects&#x2026;
</p>
<ul class="org-ul">
<li>are a common source of bugs?
</li>
<li>make testing difficult?
</li>
<li>make reasoning difficult?
</li>
<li>make parallelizing difficult?
</li>
</ul>
</div>

<ol class="org-ol"><li><a id="sec-6-6-1" name="sec-6-6-1"></a>Referential transparency<br  /><div class="outline-text-4" id="text-6-6-1">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Concept</th>
<th scope="col" class="left">Example</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">Mathematical function</td>
<td class="left">sin</td>
</tr>

<tr>
<td class="left">Function in (say) Java</td>
<td class="left">getChar</td>
</tr>
</tbody>
</table>

<p>
The behavior of <code>sin</code> depends only on its arguments; whereas the
behavior of getChar depends on an (implicit) environment.
</p>

<p>
In other words, all the dependencies of a pure function are <i>explicit</i>.
</p>
</div>

<ol class="org-ol"><li><a id="sec-6-6-1-1" name="sec-6-6-1-1"></a>Attention: contrast with the Haskell function getChar<br  /><div class="outline-text-5" id="text-6-6-1-1">
<pre class="example">
getChar :: IO Char
</pre>

<p>
we will see later that <code>IO</code> hides something:
</p>

<pre class="example">
IO x  ≃   StateOfTheWorld -&gt; (StateOfTheWorld, x)
</pre>
</div>
</li>

<li><a id="sec-6-6-1-2" name="sec-6-6-1-2"></a>Example of purity<br  /><div class="outline-text-5" id="text-6-6-1-2">
<p>
In mathematics you have <code>(sin x)^2 + (cos x)^2 = 1</code>. So, you can
always replace this complex expression by just the constant
<code>1</code>. However, in the presence of side effects, this cannot be done!
</p>
</div>
</li></ol>
</li>

<li><a id="sec-6-6-2" name="sec-6-6-2"></a>Testing is <i>much</i> easier<br  /><div class="outline-text-4" id="text-6-6-2">
<p>
For example, in order to test the function <code>getChar</code> in an imperative
language, one has to
</p>

<ul class="org-ul">
<li>emulate the user pressing key 'x'
</li>
</ul>
<pre class="example">
a = getChar()
</pre>
<ul class="org-ul">
<li>verify a == 'x'
</li>
</ul>

<p>
This might even not be enough: maybe the function depends on more
'hidden variable' (is the character buffered, &#x2026;)
</p>

<p>
Contrast the above with testing a pure function:
</p>

<pre class="example">
sin π == 0 
</pre>

<p>
In general:
</p>
<ul class="org-ul">
<li>there is no guesswork to know what a function depends on
</li>
<li>one can (relatively) easily explore the input space of the function
</li>
</ul>
</div>
</li>

<li><a id="sec-6-6-3" name="sec-6-6-3"></a>More optimizations are possible<br  /><div class="outline-text-4" id="text-6-6-3">
<p>
Examples:
</p>
<ul class="org-ul">
<li>Common Subexpression Elimination (caveat: changes the complexity of the code)
</li>
<li>Fusion
</li>
<li>&#x2026;
</li>
</ul>
</div>
</li>
<li><a id="sec-6-6-4" name="sec-6-6-4"></a>Easier parallelism/concurrency (cf. Erlang)<br  /><div class="outline-text-4" id="text-6-6-4">
<pre class="example">
x = 0
x = x+1 |in parallel with| x = x + 1
</pre>

<p>
Value of x ?     
</p>
</div>
</li>

<li><a id="sec-6-6-5" name="sec-6-6-5"></a>Possible to use laziness  (see below)<br  /></li>
<li><a id="sec-6-6-6" name="sec-6-6-6"></a>Copying and sharing<br  /><div class="outline-text-4" id="text-6-6-6">
<p>
Consider a binary tree:
</p>

<div class="org-src-container">

<pre class="src src-haskell">data Tree = Leaf
	  | Bin Tree Int Tree

tree = Bin  
	 (Bin  
	    (Bin Leaf 2  Leaf)
	    5                
	    (Bin Leaf 7  Leaf)) 
	 10                  
	 (Bin                
	    (Bin Leaf 12 Leaf)
	    20               
	    (Bin Leaf 22 Leaf))
</pre>
</div>


<div class="figure">
<p><img src="tree-orig.svg" alt="tree-orig.svg" />
</p>
</div>

<p>
And say we insert 13 in it using the function: 
</p>

<div class="org-src-container">

<pre class="src src-haskell">insert x Leaf = Bin Leaf x Leaf
insert x (Bin l y r) | x &lt; y = Bin (insert x l) y r
		     | x &gt;= y = Bin l y (insert y r)

tree2 = insert 13 tree
</pre>
</div>


<p>
The new tree <i>shares</i> most of its contents
with the old one:
</p>


<div class="figure">
<p><img src="tree-modif.svg" alt="tree-modif.svg" />
</p>
</div>
</div>

<ol class="org-ol"><li><a id="sec-6-6-6-1" name="sec-6-6-6-1"></a>Question<br  /><div class="outline-text-5" id="text-6-6-6-1">
<p>
Which nodes will be considered as garbage during the next collection,
assuming that the reference to the old tree is dropped?
</p>
</div>
</li>
<li><a id="sec-6-6-6-2" name="sec-6-6-6-2"></a>Answer<br  /><div class="outline-text-5" id="text-6-6-6-2">
<p>
black nodes: 10, 20, 12
</p>
</div>
</li></ol>
</li>
<li><a id="sec-6-6-7" name="sec-6-6-7"></a>John Carmack on Purity:<br  /><div class="outline-text-4" id="text-6-6-7">
<p>
<a href="http://www.altdevblogaday.com/2012/04/26/functional-programming-in-c/">http://www.altdevblogaday.com/2012/04/26/functional-programming-in-c/</a>
</p>

<ul class="org-ul">
<li>Functional Programming in C++
</li>
</ul>

<p>
Probably everyone reading this has heard “functional programming” put
forth as something that is supposed to bring benefits to software
development, or even heard it touted as a silver bullet.  However, a
trip to Wikipedia for some more information can be initially
off-putting, with early references to lambda calculus and formal
systems.  It isn’t immediately clear what that has to do with writing
better software.
</p>

<p>
My pragmatic summary: A large fraction of the flaws in software
development are due to programmers not fully understanding all the
possible states their code may execute in.  In a multithreaded
environment, the lack of understanding and the resulting problems are
greatly amplified, almost to the point of panic if you are paying
attention.  Programming in a functional style makes the state
presented to your code explicit, which makes it much easier to reason
about, and, in a completely pure system, makes thread race conditions
impossible.
</p>

<p>
I do believe that there is real value in pursuing functional
programming, but it would be irresponsible to exhort everyone to
abandon their C++ compilers and start coding in Lisp, Haskell, or, to
be blunt, any other fringe language.  To the eternal chagrin of
language designers, there are plenty of externalities that can
overwhelm the benefits of a language, and game development has more
than most fields.  We have cross platform issues, proprietary tool
chains, certification gates, licensed technologies, and stringent
performance requirements on top of the issues with legacy codebases
and workforce availability that everyone faces.
</p>

<p>
If you are in circumstances where you can undertake significant
development work in a non-mainstream language, I’ll cheer you on, but
be prepared to take some hits in the name of progress.  For everyone
else: No matter what language you work in, programming in a functional
style provides benefits.  You should do it whenever it is convenient,
and you should think hard about the decision when it isn’t convenient.
You can learn about lambdas, monads, currying, composing lazily
evaluated functions on infinite sets, and all the other aspects of
explicitly functionally oriented languages later if you choose.
</p>

<p>
C++ doesn’t encourage functional programming, but it doesn’t prevent
you from doing it, and you retain the power to drop down and apply
SIMD intrinsics to hand laid out data backed by memory mapped files,
or whatever other nitty-gritty goodness you find the need for.
</p>

<ul class="org-ul">
<li>Pure Functions
</li>
</ul>
<p>
A pure function only looks at the parameters passed in to it, and all
it does is return one or more computed values based on the parameters.
It has no logical side effects.  This is an abstraction of course;
every function has side effects at the CPU level, and most at the heap
level, but the abstraction is still valuable.
</p>

<p>
It doesn’t look at or update global state.  it doesn’t maintain
internal state.  It doesn’t perform any IO.  it doesn’t mutate any of
the input parameters.  Ideally, it isn’t passed any extraneous data –
getting an allMyGlobals pointer passed in defeats much of the purpose.
</p>

<p>
Pure functions have a lot of nice properties.
</p>

<p>
Thread safety.  A pure function with value parameters is completely
thread safe.  With reference or pointer parameters, even if they are
const, you do need to be aware of the danger that another thread doing
non-pure operations might mutate or free the data, but it is still one
of the most powerful tools for writing safe multithreaded code.
</p>

<p>
You can trivially switch them out for parallel implementations, or run
multiple implementations to compare the results.  This makes it much
safer to experiment and evolve.
</p>

<p>
Reusability.  It is much easier to transplant a pure function to a new
environment.  You still need to deal with type definitions and any
called pure functions, but there is no snowball effect.  How many
times have you known there was some code that does what you need in
another system, but extricating it from all of its environmental
assumptions was more work than just writing it over?
</p>

<p>
Testability.  A pure function has referential transparency, which
means that it will always give the same result for a set of parameters
no matter when it is called, which makes it much easier to exercise
than something interwoven with other systems.  I have never been very
responsible about writing test code; a lot of code interacts with
enough systems that it can require elaborate harnesses to exercise,
and I could often convince myself (probably incorrectly) that it
wasn’t worth the effort.  Pure functions are trivial to test; the
tests look like something right out of a textbook, where you build
some inputs and look at the output.  Whenever I come across a finicky
looking bit of code now, I split it out into a separate pure function
and write tests for it.  Frighteningly, I often find something wrong
in these cases, which means I’m probably not casting a wide enough
net.
</p>

<p>
Understandability and maintainability.  The bounding of both input and
output makes pure functions easier to re-learn when needed, and there
are less places for undocumented requirements regarding external state
to hide.
</p>

<p>
Formal systems and automated reasoning about software will be
increasingly important in the future.  Static code analysis is
important today, and transforming your code into a more functional
style aids analysis tools, or at least lets the faster local tools
cover the same ground as the slower and more expensive global tools.
We are a “Get ‘er done” sort of industry, and I do not see formal
proofs of whole program “correctness” becoming a relevant goal, but
being able to prove that certain classes of flaws are not present in
certain parts of a codebase will still be very valuable.  We could use
some more science and math in our process.
</p>

<p>
Someone taking an introductory programming class might be scratching
their head and thinking “aren’t all programs supposed to be written
like this?”  The reality is that far more programs are Big Balls of
Mud than not.  Traditional imperative programming languages give you
escape hatches, and they get used all the time.  If you are just
writing throwaway code, do whatever is most convenient, which often
involves global state.  If you are writing code that may still be in
use a year later, balance the convenience factor against the
difficulties you will inevitably suffer later.  Most developers are
not very good at predicting the future time integrated suffering their
changes will result in.
</p>
</div>
</li>
<li><a id="sec-6-6-8" name="sec-6-6-8"></a><span class="todo TODO">TODO</span> Downsides of purity<br  /><div class="outline-text-4" id="text-6-6-8">
<ul class="org-ul">
<li>Can be difficult to engineer efficient pure algorithms
</li>
</ul>
</div>
</li></ol>
</div>
<div id="outline-container-sec-6-7" class="outline-3">
<h3 id="sec-6-7"><span class="section-number-3">6.7</span> Continuations</h3>
<div class="outline-text-3" id="text-6-7">
</div><ol class="org-ol"><li><a id="sec-6-7-1" name="sec-6-7-1"></a>What is a continuation?<br  /><div class="outline-text-4" id="text-6-7-1">
<p>
A continuation is a part of the program <i>execution</i> that will take
place after some given point. That is, a continuation can be
represented by the point in the program to start execution plus an
environment (the values to use for the  of variables in scope at that
point).
</p>

<p>
In Haskell, one can use a mere function to represent a continuation
(the variables used in the function will automatically be saved by the
language &#x2014; remember the representation of functions as closures).
</p>
</div>
</li>

<li><a id="sec-6-7-2" name="sec-6-7-2"></a>Transformation: explicit continuations<br  /><div class="outline-text-4" id="text-6-7-2">
<p>
One can make the flow of control of a program manifest by transforming
it as follows. Each function takes an extra parameter (the
continuation).  If the function used to return a value of type <code>b</code>,
the continuation has type <code>b -&gt; eff</code> (where <code>eff</code> is abstract for now
&#x2014; we shall see later that it can be embued with arbitrary side
effects).
</p>

<p>
Instead of returning a result directly, the result is passed to the
continuation. The new return type of the function is therefore <code>eff</code>.
</p>

<p>
In order to do this transformation, one must decide an order of
execution. In this case we will evaluate the arguments first.  The
transformation can then be summarized as follows.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Object kind</th>
<th scope="col" class="left">Source</th>
<th scope="col" class="left">Target</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">Type</td>
<td class="left"><code>args -&gt; b</code></td>
<td class="left"><code>args -&gt; (b → eff) → eff</code></td>
</tr>

<tr>
<td class="left">Function params</td>
<td class="left"><code>x1 x2 ... xn</code></td>
<td class="left"><code>x1 ... xn k</code></td>
</tr>

<tr>
<td class="left">Result</td>
<td class="left"><code>result</code></td>
<td class="left"><code>k result</code></td>
</tr>

<tr>
<td class="left">Function call</td>
<td class="left"><code>f a</code></td>
<td class="left"><code>a $ \x -&gt; f x k</code></td>
</tr>
</tbody>
</table>

<p>
After this transformation, there remains ONLY tail calls. Indeed, calling the continuation
is the last step in a function. Remember
that tail calls can be implemented by simple gotos. Hence, calling
a continuation is similar to doing a GOTO, and the transformation we
have seen is similar to converting code to use explicit
gotos.
</p>

<p>
In essence, this translation is a way to explaine GOTOs only in terms
of 'functional' features; that is, in terms of the substitution model.
</p>

<p>
A functional program written with explicit continuations is said to be
in "continuation-passing style" (CPS).
</p>
</div>
</li>

<li><a id="sec-6-7-3" name="sec-6-7-3"></a>Example<br  /><div class="outline-text-4" id="text-6-7-3">
<p>
Source:
</p>
<pre class="example">
fact :: Int -&gt; Int
fact 0 = 1
fact n = n * (fact (n-1))
</pre>

<pre class="example">
test = fact 12
</pre>

<p>
Target:
</p>
<pre class="example">
fact :: Int -&gt; (Int -&gt; eff) -&gt; eff
fact 0 k = k 1
fact n k = fact (n-1) $ \fn -&gt;
           k (n * fn)  -- Mult. closure

test = fact 12 id -- the test function is not transformed.
</pre>

<p>
(Here, there is no side-effect occuring, so the type of side-effect
can be abstract)
</p>
</div>
</li>
<li><a id="sec-6-7-4" name="sec-6-7-4"></a>Recovering the stack<br  /><div class="outline-text-4" id="text-6-7-4">
<p>
By making the new closures explicit we recover the stack.
</p>

<p>
Let us fix <code>eff</code> to be <code>Int</code>, as in the example.
</p>

<pre class="example">
data FactClosures = Mult Closure -- k
                         Int     -- n
                  | Id
</pre>

<p>
(This is our stack)
</p>

<pre class="example">
apply (Mult k n) m = apply k (m * n)
apply Id         m = m
</pre>

<p>
(This function is our "return" code)
</p>

<pre class="example">
fact :: Int -&gt; Closure -&gt; Int
fact 0 k = apply k 1
fact n k = fact (n-1) $ Mult k n
</pre>

<p>
(Note how the stack is built at each step)
</p>

<pre class="example">
test = fact 12 Id
</pre>

<p>
(We start with an empty stack)
</p>

<p>
See also <a href="Final/ContinuationsStack.hs">Final/ContinuationsStack.hs</a>
</p>
</div>
</li>
<li><a id="sec-6-7-5" name="sec-6-7-5"></a>Application: accumulator side effect<br  /><div class="outline-text-4" id="text-6-7-5">
<p>
Consider this tree traversal function (which returns just the unit type)
<a href="Templates/ContinueAccum.hs">Templates/ContinueAccum.hs</a>
</p>

<p>
Let's convert it to use continuations.
Then we can use the effect type to record all the elements seen (which
effectively flattens the tree)
</p>

<p>
<a href="Final/ContinueAccum.hs">Final/ContinueAccum.hs</a>
</p>

<p>
(Note that the naive flattening function has bad time behaviour)
</p>
</div>
</li></ol>
</div>
<div id="outline-container-sec-6-8" class="outline-3">
<h3 id="sec-6-8"><span class="section-number-3">6.8</span> State</h3>
<div class="outline-text-3" id="text-6-8">
<p>
We can set the effect to a general transformation a state.  This
effectively means that we can simulate imperative programming in pure
functional programs.
</p>

<p>
Let's say we want to implement the effectful functions <code>get</code> and <code>set</code>,
which update a memory cell (of an arbitrary type <code>s</code>):
</p>

<p>
If we write the whole program in CPS, then the types become:
</p>

<p>
&#x2026; for some arbitrary effect type <code>eff</code>. Let us now pose <code>eff</code> to be
a transformation of our memory cell:
</p>

<p>
We are left to inhabit the following types:
</p>

<p>
We proceed:
</p>

<p>
The first argument of <code>k</code> is what the <code>get</code> function conceptually
returns; the second argument is the new state of the cell after
<code>get</code>. Because <code>get</code> does not modify it, we simply forward the current
state.
</p>

<p>
The first argument of <code>k</code> is what the <code>set</code> function conceptually
returns (unit); the second argument is the new state of the cell after
<code>set</code>. Because <code>set</code> changes the state to <code>newState</code>, that is what we
pass.
</p>

<p>
<a href="Final/ContinueState.hs">Final/ContinueState.hs</a>
</p>
</div>
</div>

<div id="outline-container-sec-6-9" class="outline-3">
<h3 id="sec-6-9"><span class="section-number-3">6.9</span> ✪ The State Monad</h3>
<div class="outline-text-3" id="text-6-9">
<ul class="org-ul">
<li>How can we represent imperative programs without using side effects?
</li>
<li>Idea: pass around the "state of the world" explicitly
</li>
<li>Functions are transformed as follows:
</li>
</ul>

<pre class="example">
print : String -&gt; () -- in an imperative language, the state is implicit
</pre>

<pre class="example">
print : String -&gt; State -&gt; State × () -- after making the state explicit
</pre>


<p>
Assuming the "state of the world" is only the contents of the output
file, then <code>print</code> writes in the appropriate "file" found in there. In
the simplest case, <code>State</code> is a list of characters, and <code>print</code> just
appends to it.
</p>
</div>

<ol class="org-ol"><li><a id="sec-6-9-1" name="sec-6-9-1"></a>Exercise: make the state explicit in "safePrint"<br  /><div class="outline-text-4" id="text-6-9-1">
<pre class="example">
procedure safePrint(line) : ErrorCode
  if outOfInk then
    return -1
  else
    print(line)
    return 0
</pre>

<p>
&#x2026; given the imperative function
</p>

<pre class="example">
outOfInk : Bool
</pre>
</div>

<ol class="org-ol"><li><a id="sec-6-9-1-1" name="sec-6-9-1-1"></a>Questions<br  /><div class="outline-text-5" id="text-6-9-1-1">
<ol class="org-ol">
<li>What is the type of <code>outOfInk</code> in the functional representation ?
</li>
<li>What is the translation ?
</li>
</ol>
</div>
</li>

<li><a id="sec-6-9-1-2" name="sec-6-9-1-2"></a>Answers<br  /><div class="outline-text-5" id="text-6-9-1-2">
<pre class="example">
outOfInk :: State -&gt; Bool × State

safePrint :: String -&gt; State -&gt; ErrorCode × State
safePrint    line      s1 =
   let (noInk,s2) = outOfInk s1
   in  if noInk then (-1,s2)
                else let (s3,()) = print line s2
                     in  (0,s3)
</pre>
</div>
</li></ol>
</li>

<li><a id="sec-6-9-2" name="sec-6-9-2"></a>Imperative syntax in Haskell<br  /><div class="outline-text-4" id="text-6-9-2">
<p>
<code>IP a</code> = the type of imperative programs returning a value of type <code>a</code>.
</p>

<pre class="example">
type IP a = State -&gt; State × a
</pre>

<p>
There is a generic way to sequence two values of type <code>IP a</code>:
</p>

<div class="org-src-container">

<pre class="src src-haskell">andThen :: IP a -&gt; IP b -&gt; IP b
f `andThen` g = \s0 -&gt; let (s1,a) = f s0
			   (s2,b) = g s1
		       in  (s2,b)
</pre>
</div>

<p>
But what if the 2nd program uses the returned value of the 1st?
Then (in general) the 2nd program must depend on <code>a</code>:
</p>

<div class="org-src-container">

<pre class="src src-haskell">andThen :: IP a -&gt; (a -&gt; IP b) -&gt; IP b
f `andThen` g = \s0 -&gt; let (s1,a) = f s0
			   (s2,b) = g a s1
		       in  (s2,b)
</pre>
</div>

<p>
If you <span class="underline">can</span> define a function with the above type, then Haskell gives
you special syntax for imperative programming. If you give:
</p>

<div class="org-src-container">

<pre class="src src-haskell">instance Monad IP where
  (&gt;&gt;=) = andThen
  return x = \s -&gt; (s,x)
  -- when x does not depend on the state
</pre>
</div>

<p>
Then the following is valid:
</p>

<div class="org-src-container">

<pre class="src src-haskell">safePrint line = do
  noInk &lt;- outOfInk  
  if noInk
    then return -1
    else do print line
	    return 0
</pre>
</div>

<p>
In fact, the meaning of "imperative" is given by that function
(<code>andThen</code> in our case):
</p>

<div class="org-src-container">

<pre class="src src-haskell">safePrint line = 
  outOfInk `andThen` \noInk -&gt;
  if noInk 
    then return -1
    else print line `andThen` \() -&gt;
	 return 0
</pre>
</div>
</div>
</li></ol>
</div>

<div id="outline-container-sec-6-10" class="outline-3">
<h3 id="sec-6-10"><span class="section-number-3">6.10</span> Laziness</h3>
<div class="outline-text-3" id="text-6-10">
<p>
From 'Why functional programming matters', John Hughes:
</p>

<p>
The other new kind of glue that functional languages provide enables
whole programs to be glued together. Recall that a complete functional
program is just a function from its input to its output. If f and g
are such programs, then (g . f) is a program that, when applied to
its input, computes g (f input) The program f computes its output,
which is used as the input to program g.  This might be implemented
conventionally by storing the output from f in a temporary ﬁle. The
problem with this is that the temporary ﬁle might occupy so much
memory that it is impractical to glue the programs together in this
way.  Functional languages provide a solution to this problem. The two
programs f and g are run together in strict synchronization. Program f
is started only when g tries to read some input, and runs only for
long enough to deliver the output g is trying to read. Then f is
suspended and g is run until it tries to read another input. As an
added bonus, if g terminates without reading all of f's output, then
f is aborted. Program f can even be a nonterminating program,
producing an inﬁnite amount of output, since it will be terminated
forcibly as soon as g is ﬁnished. This allows termination conditions
to be separated from loop bodies — a powerful modularization.
</p>
</div>

<ol class="org-ol"><li><a id="sec-6-10-1" name="sec-6-10-1"></a>Example: map<br  /><div class="outline-text-4" id="text-6-10-1">
<p>
Assuming
</p>

<pre class="example">
l : List Int
length l = n
</pre>

<p>
How much memory is used by <code>map</code> in the following example?
</p>

<pre class="example">
l2 = map (+1) l
</pre>
</div>
</li>

<li><a id="sec-6-10-2" name="sec-6-10-2"></a>Answer<br  /><div class="outline-text-4" id="text-6-10-2">
<p>
It depends if <code>map</code> is strict or lazy.
</p>

<p>
If <code>map</code> is strict, then it consumes <code>O(n)</code> memory.
If <code>map</code> is lazy, then it depends how much and how <code>l2</code> is used in the rest of the program.
</p>

<ul class="org-ul">
<li>If only the first element is used, then the rest of the list is not
even constructed and only <code>O(1)</code> memory is used
</li>
<li>If the whole list is used, but it is consumed at the same time
(eg. if we take its sum), then only <code>O(1)</code> memory is used
</li>
<li>If the whole list is used and kept, then it consumes <code>O(n)</code>
memory&#x2026; but we cannot say <i>when</i> the memory is consumed without
knowing the usage pattern.
</li>
</ul>


<p>
⟶ Some say: "in Haskell, lists are a <span class="underline">control structure</span>".
</p>
</div>
</li>

<li><a id="sec-6-10-3" name="sec-6-10-3"></a>Paradigm: generate and prune<br  /><div class="outline-text-4" id="text-6-10-3">
<ul class="org-ul">
<li>Generate infinite/large data structure
</li>
<li>Only visit relevant parts/prune out irrelevant ones 
<ul class="org-ul">
<li>Note that the pruned object may still be infinite
</li>
</ul>
</li>
<li>When writing a search function, the programmer can ALWAYS (and ONLY)
return a list of ALL possible results (instead of "the first one").
</li>
<li>Examples: game tree, processes
</li>
</ul>
</div>
<ol class="org-ol"><li><a id="sec-6-10-3-1" name="sec-6-10-3-1"></a>Trivia: what is the most used lazy language?<br  /><div class="outline-text-5" id="text-6-10-3-1">
<ul class="org-ul">
<li>Probably SQL!
</li>
<li>But remember also unix-shell pipes:

<p>
cat /etc/password | grep 'group=admin' | head 
</p>
</li>
</ul>
</div>
</li></ol>
</li>

<li><a id="sec-6-10-4" name="sec-6-10-4"></a>Example: Newton-Raphson Square Roots<br  /><div class="outline-text-4" id="text-6-10-4">
<div class="org-src-container">

<pre class="src src-haskell">-- Newton's method for finding the square root of 'n':
-- take a 1st guess 'x'.
-- a better guess can then be obtained by the following formula:
next n x = (x + n/x) / 2

-- Here is an infinite list of better and better guesses:
approximations n initialGuess = iterate (next n) initialGuess 

-- In an infinite list of guesses, 'within eps' finds an approximation
-- within a certain error eps
within eps (x:y:xs) = if abs (x-y) &lt; eps then y else within eps (y:xs)

-- To find the square root, construct an infinite list of
-- approximations and bound the error.
sqRoot n = within 0.01 (iterate (next n) (n/2))
</pre>
</div>
<p>
(This exmaple and the following are taken from <span class="underline">Why functional
programming matters</span> by J. Hughes.)
</p>
</div>
</li>
<li><a id="sec-6-10-5" name="sec-6-10-5"></a><span class="todo TODO">TODO</span> Example: Game tree<br  /></li>
<li><a id="sec-6-10-6" name="sec-6-10-6"></a>Transformation: explicit thunks<br  /><div class="outline-text-4" id="text-6-10-6">
<p>
First, let us define a spine-strict list.  One can have strict
structures in Haskell, by annotating constructors with an exclamation
mark.  For <a href="Strict.hs">example</a>:
</p>

<div class="org-src-container">

<pre class="src src-haskell">data SList a = Nil | Cons a !(SList a)
  deriving Show
hd (Cons x xs) = x

crash = error "I refuse."

theList = Cons "a" (Cons "b" crash)

test = hd theList
</pre>
</div>

<p>
It's possible to recover laziness by introduction of <i>explicit thunks</i>:
</p>

<div class="org-src-container">

<pre class="src src-haskell">import Prelude hiding (filter)

type Thunk x = () -&gt; x

delay :: x -&gt; Thunk x
delay x = \_ -&gt; x

-- NOTE: the function does not compute its body until the argument is
-- applied:

-- force :: (() -&gt; x) -&gt; x
force :: Thunk x -&gt; x
force t = t ()


data LList a = Nil | Cons a !(Thunk (LList a))


-- xs is evaluated to a value; but it is a function, and so its body
-- is not evaluated (yet).
hd (Cons x xs) = x


crash = error "I refuse."

instance Show a =&gt; Show (LList a) where
    show Nil = "."
    show (Cons x xs) = show x ++ "," ++ show (force xs)

theList = Cons "a" (delay (Cons "b" (delay crash)))

enumFromm :: Int -&gt; LList Int
enumFromm n = Cons n (delay $ enumFromm (n+1))

-- force a whole prefix of the list.
takeSome :: Int -&gt; LList a -&gt; [a]
takeSome 0 _ = []
takeSome n (Cons x xs) = x:takeSome (n-1) (force xs)

-- One more example:
filter :: (a -&gt; Bool) -&gt; LList a -&gt; LList a
filter p Nil = Nil
filter p (Cons x xs) = if p x then Cons x (delay $ 
					  filter p $ force xs)
			      else filter p (force xs)
</pre>
</div>
</div>
</li>

<li><a id="sec-6-10-7" name="sec-6-10-7"></a>Lazy to imperative<br  /><div class="outline-text-4" id="text-6-10-7">
<p>
What if we want to encode laziness in an imperative language?
</p>
<ul class="org-ul">
<li>First introduce explicit thunks,
</li>
<li>Then transform them into closures!
</li>
</ul>
</div>
</li>

<li><a id="sec-6-10-8" name="sec-6-10-8"></a>Memoisation and lazy dynamic programming<br  /><div class="outline-text-4" id="text-6-10-8">
<p>
Laziness as implemented in Haskell is more efficient than explicit
thunks as presented above!
</p>

<p>
Indeed, Haskell guarantees that a given thunk is never evaluated more
than once: after computation the thunk is overwritten by the
value. (As opposed to re-evaluate it every time its value is needed).
If you need to evaluate thunks many times, it's a good idea to have
explicit memoization.
</p>
</div>


<ol class="org-ol"><li><a id="sec-6-10-8-1" name="sec-6-10-8-1"></a>Example: computation of fibonacci numbers<br  /><div class="outline-text-5" id="text-6-10-8-1">
<div class="org-src-container">

<pre class="src src-haskell">import Data.Array

n = 1000000

fibs = array (0,n) [(i,f i) | i &lt;- [0..n]]
  where f 0 = 0
	f 1 = 1
	f i = fibs!(i-1) + fibs!(i-2)
</pre>
</div>

<p>
It takes some time to allocate the array. Then computing fib!50 is
instant. Then computing fib!100000 takes a bit of time. (Compare this
performance with the naive double recursion scheme.)
</p>

<p>
The efficiency of the above example relies not only on laziness, but
also on <i>memoisation</i>. That is, by using the array as an intermediate
data structure, each intermediate result is computed only once. This
is realised in the implementation by updating the thunk with its value
once it is forced.
</p>
</div>
</li></ol>
</li>

<li><a id="sec-6-10-9" name="sec-6-10-9"></a>Evil combination of features<br  /><div class="outline-text-4" id="text-6-10-9">
<p>
The combination of side effects and laziness is practically
intractable. Because of laziness code is evaluated at impredicatble
points, and thus it is very difficult to figure out when side effects
occur or not.
</p>

<p>
My advice: be <i>very cautious</i> when using side effects and lazy
evaluation together. In Haskell, beware <code>unsafePerformIO</code>!
</p>
</div>
</li></ol>
</div>
</div>
<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7"><span class="section-number-2">7</span> Concurrent programming</h2>
<div class="outline-text-2" id="text-7">
</div><div id="outline-container-sec-7-1" class="outline-3">
<h3 id="sec-7-1"><span class="section-number-3">7.1</span> Disclaimer: Concurrent programming ≠ Parallel programming</h3>
<div class="outline-text-3" id="text-7-1">
<p>
Concurrent programming = spawn independent processes, which live
independent lives (dependencies might come, but "after the fact").
</p>

<p>
Parallel programming = expose (lack of) dependencies between parts of
the computation, so that the computer can run subtasks in parallel.
</p>

<p>
In summary:
</p>
<ul class="org-ul">
<li>parallelism: about <i>speed</i>.
</li>
<li>concurrency: distribution, redundancy, etc.
</li>
</ul>

<p>
In this course we will focus on concurrency.
</p>
</div>
</div>
<div id="outline-container-sec-7-2" class="outline-3">
<h3 id="sec-7-2"><span class="section-number-3">7.2</span> Motivation: the world is concurrent</h3>
<div class="outline-text-3" id="text-7-2">
<blockquote>
<p>
The world is concurrent
Things in the world don't share data
Things communicate with messages
Things fail ⟵ the part we will not discuss in this course
</p>
</blockquote>
<p>
— Joe Armstrong
</p>
</div>
</div>
<div id="outline-container-sec-7-3" class="outline-3">
<h3 id="sec-7-3"><span class="section-number-3">7.3</span> Process</h3>
<div class="outline-text-3" id="text-7-3">
<p>
A process is an independent thread of computation. In Haskell, we can
create new processes using <code>Control.Concurrent.forkIO</code>.
</p>

<p>
For <a href="Final/Process.hs">example</a>:
</p>

<div class="org-src-container">

<pre class="src src-haskell">import Control.Concurrent
ones = do
  putStrLn "1"
  ones

twos = do
  putStrLn "2"
  twos

main = do
  forkIO twos -- create a new process
  ones
</pre>
</div>
</div>

<ol class="org-ol"><li><a id="sec-7-3-1" name="sec-7-3-1"></a>Exercise<br  /><div class="outline-text-4" id="text-7-3-1">
<ul class="org-ul">
<li>Run the above example
</li>
<li>What is the output?
</li>
</ul>
</div>
</li></ol>
</div>
<div id="outline-container-sec-7-4" class="outline-3">
<h3 id="sec-7-4"><span class="section-number-3">7.4</span> Shared state (aka Concurrent + Imperative)</h3>
<div class="outline-text-3" id="text-7-4">
<p>
How should processes communicate? First idea: via a shared memory. For
this we can use Haskell's <a href="http://hackage.haskell.org/packages/archive/base/4.4.1.0/doc/html/Data-IORef.html">IO Refs</a>.
</p>

<pre class="example">
Data.IORef.newIORef 
</pre>

<p>
Big danger of "screwing up"! 
</p>

<pre class="example">
x = 0
x = x + 1   //   x = x + 1
x ???
</pre>

<p>
We can test this using concurrent haskell:
</p>

<p>
#INCLUDE "Final/ConcurrentIORef.hs" src haskell
</p>

<ul class="org-ul">
<li>more realistic example: concurrent insertions in a balanced tree
</li>
<li>In general: access to a shared resource must be controlled.
</li>

<li>How not to screw up?
<ul class="org-ul">
<li>Semaphores
</li>
<li>Locks
</li>
<li>Critical sections
</li>
<li>Synchronized classes (monitors)
</li>
<li>&#x2026;
</li>
</ul>
</li>

<li>&#x2026; but these solutions come with problems of their own:
<ul class="org-ul">
<li>deadlocks
</li>
<li>live-locks
</li>
<li>priority inversion
</li>
<li>&#x2026;
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-7-5" class="outline-3">
<h3 id="sec-7-5"><span class="section-number-3">7.5</span> Paradigm: Concurrent + Functional</h3>
<div class="outline-text-3" id="text-7-5">
<p>
A possible approach not to screw up:
</p>
<ul class="org-ul">
<li>NO shared state!
</li>
<li>communication only happens via messages over channels.
</li>
<li>In general: a shared resource is managed by a single process
</li>
<li>Approach of <a href="http://en.wikipedia.org/wiki/Communicating_sequential_processes">CSP</a>, <a href="http://en.wikipedia.org/wiki/%CE%A0-calculus">π-calculus</a>, Erlang
</li>
</ul>

<p>
It is the approach we describe here, using "Concurrent Haskell" syntax.
</p>

<p>
For example, the ordered binary tree we discussed before would be
managed by a single process accepting (say) "insert" and "query"
messages.
</p>
</div>
</div>

<div id="outline-container-sec-7-6" class="outline-3">
<h3 id="sec-7-6"><span class="section-number-3">7.6</span> Channels</h3>
<div class="outline-text-3" id="text-7-6">
<p>
A channel is a medium for communication between processes. In Haskell,
channels can be created with the <code>newChan</code> function. (Note that the
channel is polymorphic, you may need to force the type to that you
need.)  For <a href="Channel.hs">example</a>, in the following snippet, two processes
communicate via a channel (<code>c</code>).
</p>

<div class="org-src-container">

<pre class="src src-haskell">import Control.Concurrent
import Control.Concurrent.Chan

newStringChan :: IO (Chan String)
newStringChan = newChan

reader c = do
  s &lt;- readChan c
  putStrLn $ "I have recieved: " ++ s
  reader c

writer c = do
  writeChan c "2"


main = do
  c &lt;- newStringChan
  forkIO (reader c)
  writer c
</pre>
</div>
</div>

<ol class="org-ol"><li><a id="sec-7-6-1" name="sec-7-6-1"></a>Exercise<br  /><div class="outline-text-4" id="text-7-6-1">
<p>
Execute each line of the main function in ghci, guessing what
happens beforehand.
</p>
</div>
</li></ol>
</div>

<div id="outline-container-sec-7-7" class="outline-3">
<h3 id="sec-7-7"><span class="section-number-3">7.7</span> Understanding the tradeoffs</h3>
<div class="outline-text-3" id="text-7-7">
<p>
Reading/Writing to a channel is a harmless kind of side effect&#x2026; Or is it?
</p>
<ul class="org-ul">
<li>Yes!
<ul class="org-ul">
<li>Nothing is "overwritten" (see <code>x=x+1 // x=x+1</code> example above)
</li>
<li>in particular the integrity of data structures in never
compromised.
</li>
</ul>
</li>
<li>No!
<ul class="org-ul">
<li>Referential transparency is broken (cannot replace 2 read by 1 read of the same channel)
</li>
<li>Even reading from a channel is not a proper function
</li>
<li>The integrity of a single process is guaranteed, but if there is a
an invariant involving multiple processes it may still be tricky
to maintain it.
</li>
</ul>
</li>
</ul>
</div>

<ol class="org-ol"><li><a id="sec-7-7-1" name="sec-7-7-1"></a>Example<br  /><div class="outline-text-4" id="text-7-7-1">
<p>
Assume two discrete resources, for example two tape readers. Further
assume that each tape reader is managed by a separate process
(server), with a standard protocol "open", "read", "write", "close".
</p>

<p>
Assume now two client processes with code:
</p>

<pre class="example">
do tape1 &lt;- openTape "some tape"
   tape2 &lt;- openTape "some otherTape"
   ... copy between tapes
   tape1 "close"
   tape2 "close"
</pre>

<p>
It may happen that each tape reader is allocated to either client, and
each of them will wait forever for the other to yield.
</p>

<p>
Solution: have a single processes which manages all tape readers. Its
clients must declare upfront how many tape readers they will need.
</p>
</div>
</li>

<li><a id="sec-7-7-2" name="sec-7-7-2"></a>Example<br  /><div class="outline-text-4" id="text-7-7-2">
<p>
In fact, one can simulate an updatable variable using channels and
processes. Here is how to do it:
</p>

<div class="org-src-container">

<pre class="src src-haskell">import Control.Concurrent
import Control.Concurrent.Chan

data Command a = Get (Chan a) | Set a

type Variable a = Chan (Command a)

handler :: Variable a -&gt; a -&gt; IO ()
handler v a = do
  command &lt;- readChan v
  case command of
    Set a' -&gt; handler v a'
    Get c -&gt; do 
      writeChan c a
      handler v a

newVariable :: a -&gt; IO (Variable a)
newVariable a = do
  c &lt;- newChan
  forkIO (handler c a)
  return c

get :: Variable a -&gt; IO a
get v = do
  c &lt;- newChan
  writeChan v (Get c)
  readChan c

set :: Variable a -&gt; a -&gt; IO ()
set v a = do
  writeChan v (Set a)


main = do
  v &lt;- newVariable "initial value"
  set v "new value"
  get v &gt;&gt;= putStrLn

-- interactively
</pre>
</div>
<p>
This clearly shows that, <i>if they are used indiscriminately</i>, channels
are no safer than shared memory.
</p>

<p>
In practice though, the concurrent-functional paradigm discourages
doing 'bad' things.
</p>
</div>
</li>

<li><a id="sec-7-7-3" name="sec-7-7-3"></a>Exercises<br  /><div class="outline-text-4" id="text-7-7-3">
<ul class="org-ul">
<li>Use <code>newVariable</code>, set and get in the ghci prompt.
</li>
<li>How many processes are running?
</li>
<li>Transform the handler function to do a sum instead of overwriting
when <code>set</code> is called.
</li>
<li>Can you change the program so that the get command does not need to
create a channel? (⋆⋆)
</li>
</ul>
</div>
</li></ol>
</div>

<div id="outline-container-sec-7-8" class="outline-3">
<h3 id="sec-7-8"><span class="section-number-3">7.8</span> ✪ Some erlang peculiarities</h3>
<div class="outline-text-3" id="text-7-8">
<ul class="org-ul">
<li>Syntax (inspired by prolog?!)
</li>
<li>Dynamic typing
</li>
<li>Hot-code swapping
</li>
<li>Things can fail!
<ul class="org-ul">
<li>processes crash (sometimes)
</li>
<li>messages may or may not arrive (usually they do).
</li>
</ul>
</li>
<li>Functional (like Haskell)
<ul class="org-ul">
<li>but strict.
</li>
</ul>
</li>
<li>Processes have a single "mailbox" instead of multiple channels
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-7-9" class="outline-3">
<h3 id="sec-7-9"><span class="section-number-3">7.9</span> Exercise: remote procedure call.</h3>
<div class="outline-text-3" id="text-7-9">
<p>
Write a server which accepts arguments to the function + channel where
to post the reply.
</p>
</div>

<ol class="org-ol"><li><a id="sec-7-9-1" name="sec-7-9-1"></a>Answer<br  /><div class="outline-text-4" id="text-7-9-1">
<p>
#INCLUDE "Final/RPCServer.hs" src haskell
Attention: as it is the server will only create a thunk to the
computation; only the client will force it!
</p>
</div>
</li></ol>
</div>

<div id="outline-container-sec-7-10" class="outline-3">
<h3 id="sec-7-10"><span class="section-number-3">7.10</span> Concurrency via Continuations</h3>
<div class="outline-text-3" id="text-7-10">
<p>
Possible meaning for Concurrent Programming: processes are executed in
an interleaved fashion. A process can be "put on hold" at some point,
and control is given to some other process. To understand this, we
must first capture the notion of a "running process" precisely. We are
going to use the notion of "Continuation" for this purpose.
</p>

<p>
Then, we must implement the concurrently primitives using this
representation.
</p>
</div>

<ol class="org-ol"><li><a id="sec-7-10-1" name="sec-7-10-1"></a>Example<br  /><div class="outline-text-4" id="text-7-10-1">
<p>
Let us write a server which has to manage many clients, each following
a specific sequential protocol (dialogue). It is convenient to have one process
handling each client.
</p>

<div class="org-src-container">

<pre class="src src-haskell">import Control.Concurrent
import Control.Concurrent.Chan

data Connect = Connect (Chan Request) (Chan Reply)

type Reply = String
type Request = String

------------------------------------------
-- Server code:

handleClient :: Chan Request -&gt; Chan Reply -&gt; IO ()
handleClient input output = do
  writeChan output "Username:"
  name &lt;- readChan input
  writeChan output "Password:"
  pass &lt;- readChan input
  case name == "King Arthur" &amp;&amp; pass == "Holy Grail"  of
    True  -&gt; writeChan output "You shall pass!"
    False -&gt; writeChan output "Incorrect login or password"

server :: Chan Connect -&gt; IO ()
server c = do  
  Connect input output &lt;- readChan c
  forkIO $ handleClient input output
  server c


-------------------------------------------
-- Startup code 

startServer :: IO (Chan Connect)
startServer = do  
  c &lt;- newChan
  forkIO (server c)
  return c

-- connect a client; given the server to connect to
connectClient c = do
  inp &lt;- newChan
  out &lt;- newChan
  writeChan c (Connect inp out)
  return (inp,out)

-------------------------------------
-- Test run

main = do
  s &lt;- startServer
  (i,o) &lt;- connectClient s
  writeChan i "Sir Lancelot"
  writeChan i "I seek the holy grail!"

-- Exercise: start two clients concurrently.
</pre>
</div>

<p>
This server can be written using explicit continuations, as follows.
</p>

<div class="org-src-container">

<pre class="src src-haskell">module Server where

import RuntimeSystem

-- For simplicity the queries and replies we will just be strings.
type Reply = String
type Request = String

-- Each connection to a client is implemented by a pair of channels:
-- one for queries and one for replies.
data Connection = Connect (Chan) (Chan)



------------------------------------------
-- Server code:

handleClient :: Chan -&gt; Chan -&gt; CP ()
handleClient input output k = 
  writeChan output "Username:" ( \_ -&gt;
  readChan input (\username -&gt;
  writeChan output "Password:" (\_ -&gt;
  readChan input (\pass -&gt;
  (case username == "bernardy" &amp;&amp; pass == "123" of
    True -&gt; writeChan output "Welcome to the server"
    False -&gt; writeChan output "Password or username incorrect") (\_ -&gt;
  k ())))))

server :: Chan -&gt; (() -&gt; Effect) -&gt; Effect
server c k =
  readChan c $ \[d1,d2] -&gt;
  let input = read [d1]
      output = read [d2]
  -- wait for new connections and spawn client handlers.
  in forkCP (handleClient input output) $ \_ -&gt;
  -- then loop...
  server c k


-- -------------------------------------------
-- -- Startup code 

startServer :: (Chan -&gt; Effect) -&gt; Effect
startServer k =
  newChan $ \c -&gt;
  forkCP (server c) $ \_ -&gt;
  k c

-- -- connect a new client, given access to the server.
connectClient :: Chan -&gt; CP Connection
connectClient c k =
  newChan $ \inp -&gt;
  newChan $ \out -&gt;
  writeChan c (show inp ++ show out) $ \_ -&gt;
  k (Connect inp out)

-------------------------------------
-- Test run

-- main = do
--   s &lt;- startServer
--   (i,o) &lt;- connectClient s
--  writeChan ...

-- Exercise: start two clients concurrently.
</pre>
</div>
</div>
</li>

<li><a id="sec-7-10-2" name="sec-7-10-2"></a>A continuation-based OS<br  /><div class="outline-text-4" id="text-7-10-2">
<p>
We now need to implement the concurrency primitives. To do so we must
implement an operating system &#x2014; or at least the part of an operating
system handling processes and communication between them.
</p>

<div class="org-src-container">

<pre class="src src-haskell">module RuntimeSystem where

type CP x = (x -&gt; Effect) -&gt; Effect
type Effect = Process

type ChannelIdentifier = Int
type Chan = ChannelIdentifier

type Message = String

instance Show (a -&gt; b) where
    show _ = "&lt;function&gt;"

data ChannelState = ChannelState 
		    { channelMessages :: [Message] --pending messages
		    , channelListeners :: [Message -&gt; Process] -- blocked processes
		    }
-- The state of a channel will be a list of messages and a list of listeners.
-- INVARIANT: if the system is blocked, then either list is empty

data System = System { processes :: [Process]
		     , channels :: [ChannelState]
		     }
-- The state of the system will be a list of ready processes and a
-- list of ready channels.

type Process = System -&gt; System

-- | Initial state: no channel, no process.
initialState :: System
initialState = System [] []

writeChan :: Chan -&gt; String -&gt; (() -&gt; Process) -&gt; System -&gt; System
writeChan c msg k s = scheduler $
		      updateChan c (addMessage msg) $
		      addProcess (k ()) $
		      s

readChan :: Chan -&gt; (Message -&gt; Process) -&gt; System -&gt; System
readChan c k s = scheduler $
		 updateChan c (addListener k) $
		 s

newChan :: (Chan -&gt; Process) -&gt; System -&gt; System
newChan k (System ms chs) =
  scheduler $
  addProcess (k (length chs)) $
  (System ms (chs++[ChannelState [] []]))

forkCP :: ((() -&gt; Process) -&gt; Process) -&gt; (() -&gt; Process) -&gt; System -&gt; System
forkCP spawned k s = scheduler $
		     addProcess (spawned $ \() -&gt; terminate) $
		     addProcess (k ()) $
		     s

terminate :: System -&gt; System
terminate = scheduler

------------------------------------------------
-- Scheduler
scheduler :: System -&gt; System
scheduler = simpleScheduler . unblockSystem

-- Trivial scheduler: run the 1st ready process in the list.
simpleScheduler :: System -&gt; System
simpleScheduler (System []     chans) = System [] chans     -- no ready to run process: system blocked
simpleScheduler (System (p:ps) chans) = p (System ps chans) -- run the 1st ready process

-- | Wake up listeners on a channel, as much as possible. 
-- Return new channel state, and woken up processes.
unblockListersOnAChannel :: ChannelState -&gt; (ChannelState,[Process])
unblockListersOnAChannel (ChannelState [] ws) = (ChannelState [] ws,[])
unblockListersOnAChannel (ChannelState ms []) = (ChannelState ms [],[])
unblockListersOnAChannel (ChannelState (m:ms) (w:ws)) = (ch,w m:ps)
   where (ch,ps) = unblockListersOnAChannel (ChannelState ms ws)


unblockSystem :: System -&gt; System
unblockSystem (System ps chs) = (System (ps'++ps) chs')
    where (chs',ps') = unblockChannels chs

unblockChannels :: [ChannelState] -&gt; ([ChannelState],[Process])
unblockChannels chs = (chs',concat ps)
    where (chs',ps) = unzip $ map unblockListersOnAChannel chs


--------------------------
-- helpers

-- | Add a messeage to a channel
addMessage :: Message -&gt; ChannelState -&gt; ChannelState
addMessage m (ChannelState ms ws) = ChannelState (ms++[m]) ws

-- | Update a given channel in the system
updateChan :: Chan -&gt; (ChannelState -&gt; ChannelState) -&gt; System -&gt; System
updateChan c f (System ps chs) = System ps (left++f ch:right)
    where (left,ch:right) = splitAt c chs

-- | Add a listener to a channel
addListener k (ChannelState ms ks) = ChannelState ms (k:ks)

-- | Add a process
addProcess p (System ps chs) = System (p:ps) chs
</pre>
</div>

<p>
Note: In a usual OS, there is a part dedicated to saving/restoring the
state of each process.  Here, we did it by taking advantage of
higher-order functions. The state of each process is implicitly stored
in each closure, by the implementation of the functional language.
</p>
</div>
</li>
<li><a id="sec-7-10-3" name="sec-7-10-3"></a>Exercises<br  /><div class="outline-text-4" id="text-7-10-3">
<ul class="org-ul">
<li>How many processes are created in the 1st version of the server?
</li>
<li>How many are created in the transformed version?
</li>
<li>What are the trade-offs of the transformation?
</li>
<li>Make continuations explicit closures
</li>
<li>Could you write the above server in C? How would you go about
it?
</li>
</ul>
</div>
</li>

<li><a id="sec-7-10-4" name="sec-7-10-4"></a>Remark<br  /><div class="outline-text-4" id="text-7-10-4">
<p>
Note that this sort of transformation to explicit continuations is
often performed "in the wild". Indeed, this is useful when the right
paradigm is concurrency, but the OS-level processes (or threads) are
too costly to use.
</p>

<p>
For example, in a web server, it is convenient to have a process for
each client, but there are often very many clients, and hence OS
processes are too costly.
</p>

<p>
(Older example: ATM.)
</p>
</div>
</li></ol>
</div>
</div>

<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8"><span class="section-number-2">8</span> Logic programming</h2>
<div class="outline-text-2" id="text-8">
</div><div id="outline-container-sec-8-1" class="outline-3">
<h3 id="sec-8-1"><span class="section-number-3">8.1</span> Notion: Proposition</h3>
<div class="outline-text-3" id="text-8-1">
<p>
A <i>proposition</i> is a statement. It can be a statement made about
people, the world, etc. but also about mathematical and computational
entities. The statement can be true, false, or undecided. Examples:
</p>

<ul class="org-ul">
<li>"Socrates is a man"
</li>
<li>"The lecturer has a tattoo on the sole of his left foot"
</li>
<li>123 + 345 == 567
</li>
<li>reverse [] == []
</li>
<li>p(1235) terminates
</li>
<li>there exists an x such as p(x) terminates 
</li>
<li>∀x. sin² x + cos² x == 1
</li>

<li>"X is a man"
</li>
<li>"The lecturer has a tattoo on X"
</li>
<li>sin² x + cos² x == 1
</li>
<li>reverse (x <del>+ y) == reverse y +</del> reverse x
</li>
<li>p(x) terminates
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-8-2" class="outline-3">
<h3 id="sec-8-2"><span class="section-number-3">8.2</span> Notion: Free variables, open and closed propositions</h3>
<div class="outline-text-3" id="text-8-2">
<p>
A free variable is a variable (an unknown) which is not bound by any
quantifier. Examples:
</p>

<ul class="org-ul">
<li>Socrates, 1235, John Hughes, cos: are not variables (they are fixed
entities, they have a definition)
</li>

<li>In "X is a man" or "reverse (x <del>+ y) == reverse y +</del> reverse x": x is a free variable
</li>
<li>In "there exists an x such as p(x) terminates", is bound. It is not free.
</li>
</ul>


<p>
We can then establish a distinction between <i>closed</i> and <i>open</i>
propositions. An open propostition is a proposition which has at least
one <i>free</i> variable in it.
</p>

<p>
In the context of logic programming, a free variable is often called a
<i>meta-variable</i>.
</p>

<p>
Remarks:
</p>
<ul class="org-ul">
<li>A closed proposition which can be proved ("is true") is called a
<i>Theorem</i>.
</li>
<li>In mathematics, universal quantifiers are sometimes omitted. You can read:
"sin² x + cos² x <code>= 1 is a Theorem". What is meant is "∀x. sin² x +
  cos² x =</code> 1 is a Theorem".
</li>
</ul>

<p>
The idea of logic programming is to specify values by propositions
that they have to satisfy.
</p>
</div>
</div>

<div id="outline-container-sec-8-3" class="outline-3">
<h3 id="sec-8-3"><span class="section-number-3">8.3</span> Curry</h3>
<div class="outline-text-3" id="text-8-3">
<p>
In this lecture I use the <a href="http://en.wikipedia.org/wiki/Curry_(programming_language)">Curry</a> syntax. 
</p>

<p>
The syntax of Curry is similar to Haskell. In fact, most of the simple
Haskell programs we have seen so far can run unmodified in the Curry
interpreter. However, here we will be interested in the logical
features of Curry.
</p>

<p>
In Curry a proposition is given the type <code>Success</code>. We have two
primitive ways to define propositions
</p>

<ul class="org-ul">
<li>Constrained equality operator <code>=:=</code>. Given to expressions of any type, we can specify
that they should be equal using the operator <code>=:=</code>.
</li>
<li>Conjuction operator <code>&amp;</code>. Given to propositions, we can construct
their conjunction.
</li>
</ul>

<p>
Examples:
</p>
<pre class="example">
x =:= 4
(x =:= 4) &amp; (x =:= 5)
</pre>

<p>
One can then ask if there is any value of the free variable <code>x</code> which
makes the above propositions true. ("succeed")
</p>

<p>
Type at the prompt:
</p>
<pre class="example">
x =:= 4 where x free
</pre>
<p>
or
</p>
<pre class="example">
(x =:= 4) &amp; (x =:= 5) where x free
</pre>
<p>
or
</p>
<pre class="example">
x ++ [3,4] =:= [1,2,3,4]  where x free
</pre>

<p>
In general, in Curry, we can declare a meta-variable <i>x</i> using the
"where <i>x</i> free" construct.
</p>
<pre class="example">
f = ... x ... x ....
    where x free
</pre>
</div>

<ol class="org-ol"><li><a id="sec-8-3-1" name="sec-8-3-1"></a>Read (as needed) <a href="http://www-ps.informatik.uni-kiel.de/currywiki/documentation/tutorial">the Curry tutorial</a><br  /></li>
<li><a id="sec-8-3-2" name="sec-8-3-2"></a>Interpreter<br  /><div class="outline-text-4" id="text-8-3-2">
<p>
Install either PAKCS or <a href="http://www-ps.informatik.uni-kiel.de/kics2/">KiCS2</a>:
</p>

<ul class="org-ul">
<li>KiCS2
<ul class="org-ul">
<li>More straightforward to install, at least on Linux. See the
instructions <a href="http://www-ps.informatik.uni-kiel.de/kics2/download/">here</a>.
</li>
</ul>
</li>

<li>PAKCS (not recommended)
<ul class="org-ul">
<li>MacOS (tested on Lion) install instructions:
<ul class="org-ul">
<li>Install Haskell platform
</li>
<li>For some reason the Haskell platform seems confused with the
location of gcc. Fix it:
<pre class="example">
sudo ln -s /usr/bin/gcc /Developer/usr/bin/
</pre>
</li>
<li>Install swi-prolog <b>5.10</b>
      <a href="http://www.swi-prolog.org/download/stable">http://www.swi-prolog.org/download/stable</a>
      ATTENTION: Pakcs does not work with swi-prolog 6.0!
</li>
<li>download pakcs sources and unzip
</li>
<li>build
<pre class="example">
./configure-pakcs
make
</pre>
</li>
<li>interpreter is bin/pakcs
</li>
</ul>
</li>
<li>Linux (tested on Ubuntu Oneiric):
<ul class="org-ul">
<li>Install swi-prolog <b>5.x</b>
<pre class="example">
sudo aptitude install swi-prolog
</pre>
</li>
<li>download packs Linux binary
<ul class="org-ul">
<li>32 bit: <a href="http://www.informatik.uni-kiel.de/~pakcs/download/pakcs-1.11.1-i386-Linux.tar.gz">http://www.informatik.uni-kiel.de/~pakcs/download/pakcs-1.11.1-i386-Linux.tar.gz</a>
</li>
<li>64 bit: <a href="http://www.informatik.uni-kiel.de/~pakcs/download/pakcs-1.11.1-amd64-Linux.tar.gz">http://www.informatik.uni-kiel.de/~pakcs/download/pakcs-1.11.1-amd64-Linux.tar.gz</a>
</li>
</ul>
</li>
<li>untar
</li>
<li>make
</li>
</ul>
<p>
If the installation says you need libgmp, try this package:
</p>
<pre class="example">
sudo apt-get install libgmp3c2
</pre>
</li>
<li>Run the interpreter and load file:
<pre class="example">
.../pakcs/bin/pakcs
:l Family.curry  
</pre>
</li>
<li>The <a href="http://www-ps.informatik.uni-kiel.de/~mh/pakcs/curryinput_c2p.cgi">web interface of PAKCS</a> can also be used for small examples.
</li>
</ul>
</li>
</ul>
</div>
</li></ol>
</div>

<div id="outline-container-sec-8-4" class="outline-3">
<h3 id="sec-8-4"><span class="section-number-3">8.4</span> Paradigm</h3>
<div class="outline-text-3" id="text-8-4">
<p>
Write a proposition, let the system find values for free variables
which make it true. In other words, just write a function to test if
something is a solution, the system will find the solutions for you.
</p>

<ul class="org-ul">
<li>No more functions, only relations
<ul class="org-ul">
<li>Y = f(X) is replaced by r(X,Y)
</li>
<li>if X and Y are known, r(X,Y) is a testable proposition
</li>
</ul>
</li>
<li>Provide a number of facts (axioms/rules)
</li>
<li>Let the computer search for an assignment of values to free
variables that make some statement true (proof)
</li>
</ul>


<ul class="org-ul">
<li>Main benefit: Invertible programs
<ul class="org-ul">
<li>if X known, Y is computed (f(X))
</li>
<li>if Y known, X is computed (f-1(Y))
</li>
<li>Compute both directions with one piece of code
</li>
<li>Very cool! (parser/pretty-printer, compiler/decompiler&#x2026;)
</li>
</ul>
</li>
<li>Sadly, often inefficient
<ul class="org-ul">
<li>Performance of functions inverted using the above recipe can be
terrible.
</li>
<li>As far as I know, there does not exist a "sufficiently smart
compiler" for logic programming yet.
</li>
<li>restricted to very specific domains
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-8-5" class="outline-3">
<h3 id="sec-8-5"><span class="section-number-3">8.5</span> Example: family tree</h3>
<div class="outline-text-3" id="text-8-5">
<div class="org-src-container">

<pre class="src src-curry">-- Database programming in Curry: family relationships

data Person = Adolf | Sybilla | Gustaf | Silvia | Victoria | Philip | Madeleine

parent :: Person -&gt; Person -&gt; Success
parent Adolf         Gustaf = success
parent Sybilla       Gustaf = success

parent Gustaf    Victoria   = success
parent Gustaf    Philip     = success
parent Gustaf    Madeleine  = success

parent Silvia        Victoria   = success
parent Silvia        Philip     = success
parent Silvia        Madeleine  = success

-- parent x y  ⇔  x ∈ parents y 
parents :: Person -&gt; [Person]
parents Gustaf = [Adolf,Sybilla]
parents Silvia = []
parents Victoria = [Silvia,Gustaf]
-- ...

grandparent y x = parent y z &amp; parent z x
   where z free

-- grandparent y x ⇔ y ∈ grandparents x
grandparents :: Person -&gt; [Person]
grandparents x = --- concat (map parents (parents x))
		 [y | z &lt;- parents x, 
		      y &lt;- parents z]


---- We can ask who is a parent; who is a child...

-- query: parent Gustaf x where x free


-- exercises: define grandparent, grandgrandparent, ancestor, descendents

sibling :: Person -&gt; Person -&gt; Success
sibling x y = parent z x &amp; parent z y
   where z free

-- exercise: cousin


data Gender = Male | Female

gender :: Person -&gt; Gender
gender Adolf = Male
gender Gustaf = Male
gender Sybilla = Female
gender Silvia = Female
gender Madeleine = Female
gender Victoria = Male
gender Philip = Male


male :: Person -&gt; Success
male x = gender x =:= Male
female x = gender x =:= Female

father :: Person -&gt; Person -&gt; Success
father y x = male y &amp; parent y x

mother :: Person -&gt; Person -&gt; Success
mother y x = female y &amp; parent y x
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-8-6" class="outline-3">
<h3 id="sec-8-6"><span class="section-number-3">8.6</span> Example: Map coloring</h3>
<div class="outline-text-3" id="text-8-6">
<p>
We can search for a coloring of the map of the provinces of south sweden.
</p>


<div class="figure">
<p><img src="700px-Sverigekarta-Landskap_Text.svg.png" alt="700px-Sverigekarta-Landskap_Text.svg.png" />
</p>
</div>

<div class="org-src-container">

<pre class="src src-curry">import AllSolutions

data Color = Red | Green | Blue | Yellow

neighbour :: Color -&gt; Color -&gt; Success
neighbour x y | x /= y = success

n = neighbour

southSweden (bohus,skane,blekinge,sma,hal,dals,og,vg) =
   n skane blekinge
 &amp; n skane sma
 &amp; n hal skane
 &amp; n hal sma
 &amp; n hal bohus
 &amp; n hal vg
 &amp; n bohus dals
 &amp; n bohus vg
 &amp; n vg sma
 &amp; n vg og
 &amp; n sma og
 &amp; n vg dals
 &amp; n bohus dals

main = getOneSolution southSweden
</pre>
</div>

<p>
We merely encode the neighboring relation, and require that neighbors
have different colors. Then we can let the search process look for a
solution.
</p>
</div>
</div>

<div id="outline-container-sec-8-7" class="outline-3">
<h3 id="sec-8-7"><span class="section-number-3">8.7</span> Notion: ground terms</h3>
<div class="outline-text-3" id="text-8-7">
<p>
The distinction between open/closed extends to arbitrary expressions
(terms). We say that a term is ground if it has no free variable.
</p>

<p>
Note that in other paradigms, have been working with ground terms
only: a variable was always bound 'somewhere'.
</p>
</div>
</div>
<div id="outline-container-sec-8-8" class="outline-3">
<h3 id="sec-8-8"><span class="section-number-3">8.8</span> Transformation: Functions to relations</h3>
<div class="outline-text-3" id="text-8-8">
<p>
Programming even simple programs using logic programming can be
challenging.  Fortunately, there is a receipe to transform any
functional program to a logic program, by transforming every function
into a relation.
</p>

<p>
In math, functions are often represented by their graph; that
is, by there underlying relation.
</p>

<pre class="example">
f : A → B
</pre>

<p>
means
</p>

<pre class="example">
f : A × B
(x,y₁) ∈ f and (x,y₂) ∈ f   ⇒ y₁ = y₂
</pre>


<p>
We can turn this around and encode functions as their graphs.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">source</th>
<th scope="col" class="left">target</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">f : A → B</td>
<td class="left">f : A → B → Success</td>
</tr>

<tr>
<td class="left">definition: f x = y</td>
<td class="left">assert: f x y = success</td>
</tr>

<tr>
<td class="left">expression: f(x)</td>
<td class="left">expression: y (new free variable),  with the condition f x y</td>
</tr>
</tbody>
</table>

<p>
In the following <a href="Lists.curry">example</a>, we see transform the List functions append
and reverse to relations.
</p>

<div class="org-src-container">

<pre class="src src-curry">-- data [x] = [] | x : [x]

{-
-- Source:
append0 :: [a] -&gt; [a] -&gt; [a]
append0 []     ys = ys
append0 (x:xs) ys = x : append0 xs ys
-}

-- Target:
append :: [a] -&gt; [a] -&gt; [a] -&gt; Success
append []     ys zs = ys =:= zs
append (x:xs) ys zs = (x : ws) =:= zs &amp; append xs ys ws
  where ws free

{-

Task: transform the function reverse into rev, written in relational style.

-- Source:
reverse :: [a] -&gt; [a]
reverse [] = []
reverse (x:xs) = reverse xs ++ [x]

-- Type of rev:
-- rev :: [a] -&gt; [a] -&gt; Success

-- Steps to translate the 2nd equation of the function reverse to relational style
-- (1st left as an exercise)

-- Start:

reverse (x:xs) = reverse xs ++ [x]

-- Change the left-hand-side to a relation (add an argument zs; the rhs becomes "zs =:= old result")

rev (x:xs) ys = ys =:= reverse xs ++ [x]

-- We cannot use ++ (it's a function); so we use the equivalent relation instead.  

rev (x:xs) ys = append (reverse xs) [x] ys

-- We cannot use reverse (it's a function); but we're not ready to convert it to a relation,
-- because it does not appear in the form "variable =:= reverse argument".
-- So we introduce a variable for that purpose:

rev (x:xs) ys = append ws [x] ys
		&amp; ws =:= reverse ys
   where ws free 

-- We can now replace reverse by the corresponding relation:
-- and we're done: we use only relations or data constructors.
-}
rev [] [] = success
rev (x:xs) ys = append ws [x] ys
		&amp; rev xs ws
   where ws free

-- Example queries:

-- suffix follows a given prefix?
-- append [1,2,3] ys [1,2,3,4,5] where ys free 

-- prefix precedes a given prefix?
-- append xs [4,5] [1,2,3,4,5] where xs free 


-- splitting a list
-- append xs ys [1,2,3,4,5] where xs ys free
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-8-9" class="outline-3">
<h3 id="sec-8-9"><span class="section-number-3">8.9</span> Unification</h3>
<div class="outline-text-3" id="text-8-9">
<p>
The <code>=:=</code> specifies that that two values should be <i>unified</i>.
Unification is the process of solving equation between symbolic terms.
</p>

<p>
We can get a grip on unification by examining a few examples:
</p>

<ul class="org-ul">
<li>if both sides are constants, then unification behaves as a test of
equality.  For example, <code>2 =:= 2</code> succeeds while <code>1 =:= 2</code> fails.
</li>
<li>if one side is a metavariable and the other is a constant,
unification behaves as a definition for the metavariable: <code>x =:= 2</code>
succeeds with x = 2
</li>
<li>Unification is symmetric: we could also write the following <code>2 =:=
  x</code> which succeeds with x = 2
</li>
<li>Unification can even bind multiple variables at once: <code>[x,1] =:=
  [2,y]</code> succeeds with x = 2 and y = 1
</li>
<li>But unification can also fail. For example <code>[] =:= [x,y]</code> fails:
the lists have fixed, different lengths.
</li>
<li>If both sides are variables, they become aliases of each other.
That is, if we solve both <code>x =:= y</code> and <code>y =:= 2</code> (together), then
we have x = y = 2
</li>
<li>In a single constraint, the bindings made by unification propagate
everywhere. For exam <code>[x,y,z] =:= [2,x,y]</code> succeeds with all
variables equal to 2.
</li>
<li>Unification can bind whole lists. For example <code>x:xs =:= [a,b,c]]</code>
  yields x = a, xs = [b,c].
</li>
</ul>


<p>
Unification can work on arbitrary data structures.
Given:
</p>
<pre class="example">
data Tree = Leaf Int | Bin Tree Tree
</pre>

<p>
Solving the following
</p>
<pre class="example">
Bin (Leaf x) y =:= Bin (Leaf 1) (Bin (Leaf x) (Leaf 3))
</pre>

<p>
yields
</p>
<pre class="example">
x = 1
y = Bin (Leaf 1) (Leaf 3)
</pre>

<p>
Unification can not in general solve equations involving functions.
</p>
<pre class="example">
x + 2 =:= 4
  where x free
</pre>
<p>
fails
</p>

<p>
(actually, KiCS2 is more clever and returns something!)
</p>
</div>
<ol class="org-ol"><li><a id="sec-8-9-1" name="sec-8-9-1"></a>Unification failures<br  /><div class="outline-text-4" id="text-8-9-1">
<p>
Let us examine systematically the causes of unification failure.
</p>
</div>
<ol class="org-ol"><li><a id="sec-8-9-1-1" name="sec-8-9-1-1"></a>Different structures<br  /><div class="outline-text-5" id="text-8-9-1-1">
<p>
The queries
</p>
<pre class="example">
[] =:= [x] where x free
Leaf z =:= Bin x y
</pre>
<p>
fails because lists on the left and right have rigid, different
shapes. In general, unification can succeed only if the constructors
are the same on both sides.
</p>
</div>
</li>

<li><a id="sec-8-9-1-2" name="sec-8-9-1-2"></a>Occurs check<br  /><div class="outline-text-5" id="text-8-9-1-2">
<p>
The query
</p>
<pre class="example">
x =:= (1 : x) where x free
</pre>
<p>
fails, because <code>x</code> cannot be unified with something where it occurs.
</p>

<p>
(✪) Could it make sense to succeed though?
</p>
</div>
</li></ol>
</li>

<li><a id="sec-8-9-2" name="sec-8-9-2"></a>Unification algorithm<br  /><div class="outline-text-4" id="text-8-9-2">
<p>
Informally, unification works as follows:
</p>
<ul class="org-ul">
<li>Unification should return a substitution. (A substitution is a
mapping from metavariables to terms.)
</li>
<li>A variable which is uninstantiated—i.e. no previous unifications
were performed on it—can be unified with an atom, a term, or another
uninstantiated variable, thus effectively becoming its alias. A
variable cannot be unified with a term that contains it; this is the
so called occurs check.
</li>
<li>Two atoms can only be unified if they are identical.
</li>
<li>Similarly, a term can be unified with another term if the top
function symbols and arities of the terms are identical and if the
parameters can be unified simultaneously. Note that this is a
recursive behavior.
</li>
</ul>

<p>
In order to implement the above, we need to generalize it, to work on
a list of unification constraints and a current substitution, which
can be seen as a partial result of the algorithm.
</p>

<p>
The algorithm is then as follows. Assume a list of assertions <code>ts</code> of
the form <code>{t₁=t'₁,...}</code> and a substitution <code>s</code>. If <code>ts</code> is empty, the result is
<code>s</code>. Otherwise extract the first assertion in <code>ts</code> and proceed by case
analysis:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">First assertion in <code>s</code></th>
<th scope="col" class="left">Action</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">t = t</td>
<td class="left">continue</td>
</tr>

<tr>
<td class="left">C(t₁,&#x2026;) = C(t'₁,&#x2026;)</td>
<td class="left">add the assertions t₁=t'₁,&#x2026; to ts</td>
</tr>

<tr>
<td class="left">C(t₁,&#x2026;) = D(t'₁,&#x2026;)</td>
<td class="left">fail</td>
</tr>

<tr>
<td class="left">x = t where x occurs in t</td>
<td class="left">fail</td>
</tr>

<tr>
<td class="left">x = t where x does not occur in t</td>
<td class="left">apply the substitution <code>x ==&gt; t</code> to <code>s</code> and <code>ts</code>, add it to <code>s</code></td>
</tr>

<tr>
<td class="left">t = x</td>
<td class="left">restart with x = t</td>
</tr>
</tbody>
</table>

<p>
In code:
</p>

<div class="org-src-container">

<pre class="src src-haskell">module Unify where

import qualified Data.Map as M
import Data.Map (Map)

type Variable = String

-- Variable representation?
-- Term representation?
data Term = Con String [Term]
	  | Var Variable -- metavar
  deriving (Show)
-- Substitution?

type Substitution = Map String Term

both :: (t -&gt; t1) -&gt; (t, t) -&gt; (t1, t1)
both f (x,y) = (f x, f y)

-- Unification
unify :: [(Term,Term)] -&gt; Substitution -&gt; Maybe Substitution
-- Invariant: if x appears in the (source) of the substitution, then it does not
-- occur anywhere in the constraints.
unify [] s = Just s
unify ((Con c1 args1,Con c2 args2):constraints) s
  | c1 /= c2 = Nothing
  | length args1 == length args2 = unify (zip args1 args2++constraints) s
  | otherwise = Nothing
unify ((Var x,Var x'):constraints) s
  | x == x' = unify constraints s
unify ((Var x,t):constraints) s
  | x `occursIn` t = Nothing
  | otherwise
  = unify (map (both (applySubst (x==&gt;t))) constraints) (s +&gt; (x ==&gt; t))
unify ((t,Var x):cs) s = unify ((Var x,t):cs) s

term1 = Con "Bin" [Con "Leaf" [Var "x"],
		   Var "y"]

term2 = Con "Bin" [Con "Leaf" [Con "1"[]],
		   Con "Bin" [Con "Leaf" [Var "x"]
			     ,Con "Leaf" [Con "Leaf" [Con "3" []]]]]

testUnify = unify [(term1,term2)] M.empty


--------------------
-- Occurs check

-- Metavariables in a term
varsOf :: Term -&gt; [Variable]
varsOf (Var x) = [x]
varsOf (Con _ args) = concat $ map varsOf args

occursIn :: Variable -&gt; Term -&gt; Bool
occursIn v t = v `elem` varsOf t

--------------------------------
-- Substitution management

-- | Identity (nothing is substituted)
-- idSubst = M.empty

-- | Add an "assignment" to a substitution
(+&gt;) :: Substitution -&gt; Substitution -&gt; Substitution
bigS +&gt; smallS = M.union (applySubst smallS `fmap` bigS) smallS

-- | Single substitution
(==&gt;) :: String -&gt; Term -&gt; Substitution
x ==&gt; t = M.singleton x t

-- | Apply a substitution to a term
applySubst :: Substitution -&gt; Term -&gt; Term
applySubst s (Var x) = case M.lookup x s of
  Nothing -&gt; Var x
  Just t -&gt; t
applySubst s (Con cname args) = Con cname (map (applySubst s) args)

unify2 s t = unify [(s,t)] M.empty
</pre>
</div>
</div>
</li>
<li><a id="sec-8-9-3" name="sec-8-9-3"></a>(✪) Implementing unification in an imperative language<br  /><div class="outline-text-4" id="text-8-9-3">
<p>
A possible way to implement unification by using side effects is the
following. Each occurence of a meta-variable should be represented by
a reference to the meta-variable. When the unification algorithm gets
a constraint of the form
</p>
<pre class="example">
variable = value
</pre>
<p>
then the meta-variable can be overwritten with the <code>value</code> above.
</p>

<p>
This works even if the value is a meta-variable itself (call it
<code>y</code>). Indeed, the unification will overwrite the original
meta-variable with a reference to <code>y</code>. Later, when <code>y</code> becomes bound,
it will be overwritten with a value &#x2014; and all the references to it
will take the new value of <code>y</code>, including the ones created by
unification.
</p>
</div>

<ol class="org-ol"><li><a id="sec-8-9-3-1" name="sec-8-9-3-1"></a>Question<br  /><div class="outline-text-5" id="text-8-9-3-1">
<p>
How do we reconciliate referential transparency with the need to
"update" the bindings of meta-variables?
</p>

<p>
Answer: if a piece of code works on an unbound variable, it really is
independent of is value. Therefore if the variable is bound later to
an actual value, the "update" has no effect on the results obtained.
</p>
</div>
</li></ol>
</li>

<li><a id="sec-8-9-4" name="sec-8-9-4"></a>(✪) Reading<br  /><div class="outline-text-4" id="text-8-9-4">
<p>
Wikipedia has a <a href="http://en.wikipedia.org/wiki/Unification_(computer_science)">good article</a> on unification.
</p>
</div>
</li></ol>
</div>
<div id="outline-container-sec-8-10" class="outline-3">
<h3 id="sec-8-10"><span class="section-number-3">8.10</span> Transformation: Relations to Functions</h3>
<div class="outline-text-3" id="text-8-10">
<p>
Understanding relations
Relations are sometimes (often) not functions. There can be no
solution to an equation, and sometimes there can be more than one.
</p>
</div>
<ol class="org-ol"><li><a id="sec-8-10-1" name="sec-8-10-1"></a>Backtracking<br  /><div class="outline-text-4" id="text-8-10-1">
<p>
If at some point one encounters a failure (for example unification
fails), <b>backtrack</b> to the last disjunction and try the other branch.
</p>

<p>
This requires that you remember the "state of the world" at each
disjunction point.
</p>

<p>
Example: solve the query:
</p>

<pre class="example">
append xs ys "hello"  
     where xs,ys free
</pre>

<p>
(Branching point A)
1st case. Maybe the equation
</p>

<pre class="example">
append [] ys zs = ys =:= zs 
</pre>

<p>
applies? We try to unify the two calls to append and collect the
equations. This succeeds and gives:
</p>

<pre class="example">
ys =:= zs 
     where ys free
           xs = []
           zs = "hello"
</pre>

<p>
Solving the remaining unification constraint yields:
</p>

<pre class="example">
success
     where xs = []
     where ys = "hello"
</pre>

<p>
And this is our 1st solution. Now, we can <i>backtrack</i> to the branching
point A, and try the 2nd equation (I have renamed variables to avoid
clashes):
</p>

<pre class="example">
append (x:xs') ys zs = append xs' ys zs' &amp;
                   zs =:= x:zs'
   where zs' free
</pre>


<p>
Which rewrites our goal to 
</p>

<pre class="example">
                append xs' ys zs' &amp;
                "hello" =:= x:zs'
where zs' free
      xs = x:xs'
      ys free    
      x  free
      xs' free 
</pre>

<p>
Solving the 2nd unification constraint yields:
</p>

<pre class="example">
                append xs' ys "ello"
where xs = 'h':xs'
      ys free     
      x = 'h'
      xs' free 
</pre>


<p>
Again there are 2 ways to solve the remaining goal. (So we have
another branching point B here.)
</p>

<p>
Proceeding with the 1st equation for append yields (similarly as
before)
</p>

<pre class="example">
xs' = []
ys = "ello"
</pre>

<p>
and thus the final solution:
</p>

<pre class="example">
xs = "h"
ys = "ello"
</pre>

<p>
At this point one can backtrack to the point B, and continue with the
2nd equation for append, etc.
</p>

<p>
Note that this process works only if the program is written in the
pure relational style.
</p>

<p>
We can implement all this in Haskell as follows:
</p>

<p>
<a href="Final/Search.hs">Final/Search.hs</a>
</p>
</div>
</li>

<li><a id="sec-8-10-2" name="sec-8-10-2"></a>List of successes<br  /><div class="outline-text-4" id="text-8-10-2">
<p>
Explicit representation of disjunction. That is, suppose we want to
encode the (inverse) of the Parent relation from <a href="Family.curry">Family.curry</a> as
a function children, such as:
</p>

<pre class="example">
parent x y ⇔ y ∈ children x
</pre>

<div class="org-src-container">

<pre class="src src-haskell">children :: Person -&gt; [Person]
children Gustaf = [Victoria,Philippe,Madeleine]
children Adolf  = ...
</pre>
</div>

<p>
exercise: write the function "parents", such as 
</p>

<pre class="example">
parent x y ⇔ x ∈ parents y
</pre>

<p>
We can now translate sibling function as follows:
</p>

<pre class="example">
siblings x  :: Person -&gt; [Person]
siblings x = concat (map children (parents x))
</pre>

<p>
this pattern is so common that there is special syntax for it: list
comprehension.
</p>

<pre class="example">
siblings x = [ y | z &lt;- parents x,  y &lt;- children z]
</pre>

<p>
Each free variable must range over its possible values.
</p>
</div>
</li></ol>
</div>

<div id="outline-container-sec-8-11" class="outline-3">
<h3 id="sec-8-11"><span class="section-number-3">8.11</span> Search in general</h3>
<div class="outline-text-3" id="text-8-11">
<p>
<a href="Final/Search">Final/Search</a>
</p>

<p>
Note that our interpreter does not support unification as a
relation, but we can define it as follows:
</p>

<p>
unify(x,x) = success
</p>

<p>
or in prolog syntax
</p>

<p>
unify(X,X).
</p>
</div>

<ol class="org-ol"><li><a id="sec-8-11-1" name="sec-8-11-1"></a>Other Implementations<br  /><div class="outline-text-4" id="text-8-11-1">
<p>
Here we have barely touched the possible ways to implement logic
programming.  For example, Curry uses 'narrowing' instead of
backtracking searches. This is more efficient and allows to mix logic
and functional paradigms.
</p>

<p>
There are many more ways to implement logic programming.  We won't
discuss those here; there is lots of literature for the interested.
</p>
</div>
</li></ol>
</div>
</div>

<div id="outline-container-sec-9" class="outline-2">
<h2 id="sec-9"><span class="section-number-2">9</span> Outlook</h2>
<div class="outline-text-2" id="text-9">
<p>
The following graph is an overview of all the transformations seen in
the course.
</p>

<p>
(NOTE: You should know also how to "revert" a transformation!)
</p>


<div class="figure">
<p><img src="transformations.svg" alt="transformations.svg" />
</p>
</div>
</div>
</div>

<div id="outline-container-sec-10" class="outline-2">
<h2 id="sec-10"><span class="section-number-2">10</span> ✪ Postlude: Where to go from here?</h2>
<div class="outline-text-2" id="text-10">
</div><div id="outline-container-sec-10-1" class="outline-3">
<h3 id="sec-10-1"><span class="section-number-3">10.1</span> Exam :)</h3>
<div class="outline-text-3" id="text-10-1">
<ul class="org-ul">
<li>review the code that we went through in the lectures
</li>
<li>re-do the exercises
</li>
<li>exam will be in the same style
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-10-2" class="outline-3">
<h3 id="sec-10-2"><span class="section-number-3">10.2</span> More features we did not discuss:</h3>
<div class="outline-text-3" id="text-10-2">
<ul class="org-ul">
<li>Exceptions
</li>
<li>(Inequational) Constraints
</li>
<li>Stack-based
</li>
<li>&#x2026;
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-10-3" class="outline-3">
<h3 id="sec-10-3"><span class="section-number-3">10.3</span> Explore the paradigms you like!</h3>
<div class="outline-text-3" id="text-10-3">
<p>
You can take courses dedicated to specific paradigms
</p>
<ul class="org-ul">
<li>Functional ((advanced) functional programming)
</li>
<li>Concurrent (concurrent programming TDA381)
</li>
<li>Object oriented
</li>
<li>Logic (partly covered in Formal Methods)
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-10-4" class="outline-3">
<h3 id="sec-10-4"><span class="section-number-3">10.4</span> Invent your own paradigm!</h3>
<div class="outline-text-3" id="text-10-4">
<ul class="org-ul">
<li>&#x2026; that suits the way you think
</li>
<li>&#x2026; that suits your favorite application domain
</li>
<li>Partly covered in the AFP Course
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-10-5" class="outline-3">
<h3 id="sec-10-5"><span class="section-number-3">10.5</span> Translations "in the large"</h3>
<div class="outline-text-3" id="text-10-5">
<p>
Courses:
</p>
<ul class="org-ul">
<li>Programming Languages (Theory?)
</li>
<li>Compiler construction Course
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-10-6" class="outline-3">
<h3 id="sec-10-6"><span class="section-number-3">10.6</span> Formal study of Syntax, Types</h3>
<div class="outline-text-3" id="text-10-6">
<ul class="org-ul">
<li>Programming Languages Course
</li>
<li>"Types and Programming Languages", Pierce
</li>
<li>Types For Proofs And Programs Course
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-10-7" class="outline-3">
<h3 id="sec-10-7"><span class="section-number-3">10.7</span> A lot more to read</h3>
<div class="outline-text-3" id="text-10-7">
<ul class="org-ul">
<li>The essence of functional programming (Wadler) — Actually a tutorial on monads.
</li>
<li>Poor man's concurrency monad (Claessen)
</li>
<li>The essence of list comprehensions (Wadler)
</li>
<li>Introduction to programming with shift and reset <a href="http://okmij.org/ftp/continuations/index.html#tutorial1">http://okmij.org/ftp/continuations/index.html#tutorial1</a>
</li>
<li>Transforming failure into a list of successes (Wadler)
</li>
<li>Typed logical variables in Haskell
</li>
<li>Continuation-based multiprocessing
</li>
<li>Continuation-Based Program Transformation Strategies
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-10-8" class="outline-3">
<h3 id="sec-10-8"><span class="section-number-3">10.8</span> A master/candidate project on Programming Languages?</h3>
</div>
</div>

<div id="outline-container-sec-11" class="outline-2">
<h2 id="sec-11"><span class="section-number-2">11</span> Local Words (ignore)</h2>
<div class="outline-text-2" id="text-11">
<p>
LocalWords:  stylesheet css href html renderer Neumann shaper Perlis
LocalWords:  Clojure de Erlang's multithreading GOTO Hoare's izable
LocalWords:  shapers Prolog Prolog's Monads someValue ItsType greetMe
LocalWords:  FP Lampson goto gotos bubbleSort tmp addressOf PointerTo
LocalWords:  variableAt inlining ok sqrt sqrtArgument sqrtResult rhs
LocalWords:  sqrtCaller acc foreach GC OOP Firefox ShiftByDays ymd th
LocalWords:  shiftByDays ADT petDog createDog petCat createCat Liskov
LocalWords:  iff Wikipedia Vocalise StrayCat wikipedia AnimalMethods
LocalWords:  DogMethods dogMethods Javascript SmartPhone GradStud src
LocalWords:  svg cmdline Kdot Tsvg birthDate eg CourseGrade TODO OO
LocalWords:  numberOfStudents gradstudent struct ListOfInt foldr env
LocalWords:  multiplyBy squareAll mutliple args ys arg
LocalWords:  currification recursiveCall MultipyBy EventListener IP
LocalWords:  MyPrintAction onPress safePrint ErrorCode outOfInk noInk
LocalWords:  andThen Awk parallelizing getChar StateOfTheWorld CSE hs
LocalWords:  Carmack multithreaded externalities codebases monads SQL
LocalWords:  SIMD intrinsics nitty allMyGlobals const Reusability CSP
LocalWords:  codebase FIXME unix memoization Subnote subtasks IORef
LocalWords:  newIORef newChan ghci updatable CSPVariable newVariable
LocalWords:  erlang prolog ServerWithContinuations quux PAKCS MacOS
LocalWords:  gcc sudo ln swi Pakcs pakcs untar KiCS uninstantiated zs
LocalWords:  unifications arities reconciliate decompiler ello inline
LocalWords:  derecursification defunctionalization fct TDA AFP
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Jean-Philippe Bernardy</p>
<p class="date">Created: 2016-03-03 tor 07:42</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.5.2 (<a href="http://orgmode.org">Org</a> mode 8.2.10)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>

<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Gabuzomeu - My Cubical Type-Theory</title>
        <link rel="stylesheet" type="text/css" href="../css/navigation.css" />
        
        <link rel="stylesheet" type="text/css" href="../css/home.css" />
        
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">Gabuzomeu</a>
            </div>
            <div id="navigation">
                <a href="../">Home</a>
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../recent.html">Recent</a>
            </div>
        </div>

        <div id="content">
            <h1>My Cubical Type-Theory</h1>

            <div class="info">
    Last updated on August 27, 2015
    
        by Jean-Philippe Bernardy
    
</div>
<div class="info">
    
        Tags: 
    
</div>

<h1 id="motivation">Motivation</h1>
<p>Once upon a time I stumbled upon a piece by Phil Wadler where he shows that deductive natural numbers satisfy the principle of induction.</p>
<p>Here is the definition of deductive natural numbers:</p>
<pre><code>Nat : Type
Nat = (α : Type) → α → (α → α) → α

zero : Nat
zero = λα z s. z

succ : Nat -&gt; Nat
succ n = λα z s. s (n α z s)</code></pre>
<p>And here is the principle of induction:</p>
<pre><code>Induction = (x : Nat) -&gt; P zero -&gt; ((m : Nat) -&gt; P m -&gt; P (succ m)) -&gt; P x</code></pre>
<p>Folklore has it that the principle of induction is irreducible: if you try to prove it, then you have to suppose an underlying principle of induction somewhere else.</p>
<p>Thus, Wadler’s remark is quite intriguing, because one seemingly gets induction out of nowhere. However, Wadler’s proofs relies on both: 1. parametricity and 2. extensionality. Thus, when I first learned about Wadlers’ remark, I was not too surprised: neither parametricity nor extensionality where supported in proof assisstants; it was therefore impossible to prove <code>Induction</code>.</p>
<p>However, later on, we managed to construct a type-theory with internal parametricity. Several type-theories with extensionality have sprung up as well. However, until recently, it was not clear how to mix the two in a single consistent model.</p>
<p>In this note, I will outline a type-theory which supports both aspects.</p>
<h1 id="back-to-basics">Back To Basics</h1>
<p>I’ll be assuming the usual common base for type theories, which can be summed as follows:</p>
<ol style="list-style-type: decimal">
<li>Types are types. I won’t care about universe levels here: the usual story applies.</li>
<li>You can get stuff out of the context</li>
<li>There is a decidable relation of conversion between terms, which gives a notion of definitional equality.</li>
</ol>
<pre><code>                             x:A  ∈                 Γ ⊢ t : A   A = B
 ––––––––––––– ax         ––––––––––––– var       –––––––––––––––––––– conv
   Γ ⊢ U : U                Γ ⊢ x : A                 Γ ⊢ t : B
</code></pre>
<p>We can then also assume a type of (dependent) functions. Here are its formation, introduction and elimination rules.</p>
<pre><code>                                                                 Γ ⊢ t : A
  Γ ⊢ A:U Γ,x:A ⊢ B : U            Γ, x:A ⊢ t : B                Γ ⊢ s : (x:A) → B
 ––––––––––––––––––––––– Π    –––––––––––––––––––––––– abs     –––––––––––––––––––– app
   Γ ⊢ (x:A) → B : U           Γ ⊢ λx. t : (x:A) → B             Γ ⊢ s t : B[t/x]
</code></pre>
<p>The only conversion rules are β and η reduction:</p>
<p><code>(λx. t) u = t[u/x]</code> and <code>(λx. t x) = t</code> when <code>x</code> does not occur in <code>t</code>.</p>
<h1 id="nominal-type-theory">Nominal Type Theory</h1>
<p>The key idea is that we want to define terms that have (hyper-) cubical shapes. To be able to do this we need terms that depend on an interval, say <code>[0,1]</code>. Depending on an interval generates a line, depending on two intervals generates a square, depending on three intervals generates a cube, and so on.</p>
<p>Here is are formation, introduction rules for lines. We use the letters <code>i,j</code> for variables that range over intervals. We will call such variables <em>names</em>.</p>
<pre><code>    Γ,i ⊢ A : U             Γ, x:A ⊢ t : B
 ––––––––––––––––– ∀     –––––––––––––––––––––––– name-abs
   Γ ⊢ ∀i.A : U             Γ ⊢ &lt;i&gt; t : ∀i. A</code></pre>
<p>We will say that a value of type <code>∀i. A‵ is a A-line. In particular, a value of type</code>∀i. U‵ is a line type.</p>
<p>Application to a constant (<code>0</code>,<code>1</code>) offers no particular surprise:</p>
<pre><code>Γ ‌⊢ s : ∀i.A
–––––––––––––––– 0
Γ ⊢ s@0 : A[0/i]

Γ ‌⊢ s : ∀i.A
–––––––––––––––– 1
Γ ⊢ s@1 : A[1/i]</code></pre>
<p>I want to disallow name aliasing, and therefore will arrange the application to consume the variable that is applied. One possible typing rule is thus:</p>
<pre><code>Γ ‌⊢ s : ∀i.A
––––––––––––––––––––– name-app-last
Γ,j ⊢ s@j : A[j/i]</code></pre>
<p>However, the above rule can only be used if the name is the last thing introduced in the context (we have dependent types; the order of things in the context matters).</p>
<p>In order to generalize to arbitrary positions of <code>j</code>, we must be careful. The trick is to abstract the context over <code>j</code>, the name that disappears. Here is how the rule looks like if there is an extra variable introduced after it. (I don’t have good notation for the arbitrary long context.)</p>
<pre><code> Γ, y:∀j.B ‌⊢ s : ∀i.A[y@i/x]
–––––––––––––––––––––––––––––– name-app-var
    Γ,j,x:B ⊢ s@j : A[j/i]</code></pre>
<p>This trick is due to Simon Huber. It makes the name application rule quite tricky: the type of some varables change “under your feet” as you use it. However, the alternatives that I know of are even worse, so we’ll stick to it and be careful.</p>
<p>Here are the conversion rules:</p>
<p><code>(&lt;i&gt;t)@0 = t[0/i]</code> <code>(&lt;i&gt;t)@1 = t[1/i]</code> <code>(&lt;i&gt;t)@j = t[j/i]</code> <code>&lt;i&gt;(t@i) = t</code></p>
<p>Remark: in reality, the rules so far say nothing about lines or cubes. They admit models that only talk about an abstract notion of names. I posit that, if we were to omit the designated special names 0 and 1, the type-theory so far should be quite useful to represent nominal objects.</p>
<h1 id="my-cubical-type-theory">(My) Cubical Type Theory</h1>
<p>As I see it, the main interest of cubical type-theory is to group objects (<code>a</code>,<code>b</code>) with a useful relation <code>p</code> between them by placing <code>a</code> and <code>b</code> at the borders of a line and <code>p</code> in the interior. In such a situation we will say that <code>p</code> is a path between <code>a</code> and <code>b</code>. Here are my rules for path formation, introduction and elimination.</p>
<pre><code>  Γ ⊢ A : ∀i. U                                           Γ ⊢ s : A@0
  Γ ⊢ s : A@0                                             Γ ⊢ t : A@1
  Γ ⊢ t : A@1                 Γ ⊢ t : ∀i. A               Γ ⊢ u : s←–A–→t
–––––––––––––––––– path  –––––––––––––––––––––––––– in  –––––––––––––––––––––––– line
 Γ ⊢  s←–A–→t : U         Γ ⊢  t! : t@0←–&lt;i&gt;A–→t@1       Γ ⊢ (s,t,u) : (A@0,A@1,s←–A–→t)</code></pre>
<p>The formation rule says that a path type over the line type A is well formed if the borders have the borders of A as types. The introduction says that from any line, one can get a path between its borders. The elimination rule says that any path can be completed to a full line.</p>
<p>Conversion rules:</p>
<pre><code>(s,t,u)@0     = s
(s,t,u)@1     = t
(s,t,u)!      = u
(s,t,u!)      = u
(A,B,s←–R–→t) = R -- attn! subtyping</code></pre>
<p>In my opinion, the main interest of this theory is that path relations behave extensionally. Indeed, for any two functions <code>f</code> and <code>g</code> of type <code>(X:A) → B</code>, we have:</p>
<pre><code>q : (x:A) → (y:A) → (p : x←–&lt;i&gt;A–→y) → f x ←–&lt;i&gt;B–→g x
–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
?  :   f←–(&lt;i&gt;(x:A) → B)–→g</code></pre>
<p>where <code>? = (λx. (f x@0,g x@1,q _ _ x!)@i)!</code> Checking the type is left as an exercise to the reader. Attention: the type of <code>x</code> changes when <code>i</code> is used.</p>
<p>Other exercise: prove the other direction.</p>
<h1 id="parametricity">Parametricity</h1>
<p>Given the above base, we can easily internalise parametricity. We need the ability to turn any relation into a path between the types that it relates. (That may seem strange to those used to CTT; however, remember at this point that our notion of path is rather weak, in particular they do not have substitutivity.)</p>
<pre><code>Γ ⊢ A : U
Γ ⊢ B : U
Γ ⊢ R : A → B → U
––––––––––––––––––––
Γ ⊢ ΨR : A←–&lt;i&gt;U–→B</code></pre>
<p>The conversion rule says that a witness for the relation is a proper inhabitant of such a path:</p>
<p><code>a←–(_,_,ΨR)–→b = R a b</code></p>
<p>A consequence is that every parametricity theorem is provable within the theory. (The proof of this fact appears <a href="http://www.cse.chalmers.se/~mouling/share/PresheafModelParametericTT.pdf">here</a>; using a somewhat different syntax.) For good measure I will give an example: the proof of parametricity for the identity function type:</p>
<pre><code>f : (a:U) → a -&gt; a
A : U
B : U
R : A → B → U
a : A
b : A
p : R a b
––––––––––––––––––––––––
? : R (f A a) (f B b)</code></pre>
<p>where <code>? = (&lt;i&gt; f (A,B,ΨR)@i (a,b,p)@i)!</code></p>
<h1 id="extensionality">Extensionality</h1>
<pre><code> Γ ⊢ t : A@0
 Γ ⊢ A : ∀i. U
–––––––––––––––––––
 Γ ⊢ t↑A : ∀i. A@i</code></pre>
<p>This gives both the coercion and the coherence components of OTT, all at once. With the same assumptions:</p>
<pre><code>coe t A : A@1
coe t A = (t↑A)@0

coh t A : t←–A–→coe t A
coh t A = (t↑A)!</code></pre>
<p>The conversion rules for <code>↑</code> work by case analysis on the second argument (the line type).</p>
<pre><code>A    ↑ &lt;i&gt;U            =  &lt;i&gt;A
s    ↑ &lt;i&gt;((x:A) → B)  =  &lt;i&gt;λx. (s x@0 ↑ B)@i
t    ↑ &lt;i&gt;∀j.A         =  &lt;i&gt;&lt;j&gt;(t@j ↑ &lt;i&gt;A)@i
u    ↑ &lt;i&gt;(s←–A–→t)    =  &lt;i&gt;((s[0/i],t[0/i],u)↑&lt;i&gt;∀j.A@j)@i!</code></pre>
<p>(Additionally <code>(t ↑ A)@0 = t</code>)</p>
<p>Note that we have no satisfactory conversion for <code>&lt;i&gt;(_,_,ΨR)</code>. Parametricity is a-priori not compatible with</p>
<pre><code>x : A
y : A
p : x←–&lt;i&gt;A–→y
P : A → U
q : P x
–––––––––––––––– subst
? : P y</code></pre>
<p><code>? = (q ↑ (&lt;i&gt;P (x,y,p)@i))@1</code></p>
<p>Splice in univalence:</p>
<h1 id="univalence">Univalence</h1>
<pre><code>Γ ⊢ A : U
Γ ⊢ B : U
Γ ⊢ R : A → B → U
Γ ⊢ f : A → B
Γ ⊢ f' : B → A
Γ ⊢ g  : (x:A) → R x (f x)
Γ ⊢ g' : (x:B) → R (f x) x
–––––––––––––––––––––––––––
Γ ⊢ ⟨R,f,g,f',g'⟩ : A←–&lt;i&gt;U–→B</code></pre>
<p>with</p>
<p><code>a←–(_,_,⟨R,_,_,_,_⟩)–→b = R a b</code></p>
<p>and</p>
<pre><code>s ↑ (_,_,⟨R,f,g⟩)  =  (s, f s, g s)</code></pre>
<h1 id="semivalence">Semi–valence</h1>
<pre><code>Γ ⊢ A : U
Γ ⊢ B : U
Γ ⊢ R : A → B → U
Γ ⊢ f : A → B
Γ ⊢ g : (x:A) → R x (f x)
–––––––––––––––––––––––––––
Γ ⊢ ⟨R,f,g⟩ : A←–&lt;i&gt;U–→B</code></pre>
<p>with</p>
<p><code>a←–(_,_,⟨R,f,g⟩)–→b = R a b</code></p>
<p>and</p>
<pre><code>s ↑ (_,_,⟨R,f,g⟩)  =  (s, f s, g s)</code></pre>
<h1 id="acks">Acks</h1>
<p>Conor McBride pointed me an issue with symmetry.</p>

        </div>
        <div id="footer">
            Site generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
